<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/logo_miccall.png"/>
	<link rel="shortcut icon" href="/img/logo_miccall.png">
	
			    <title>
    阿诺撕码辛格
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="niuoke" />
    
    	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	 
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/bg.jpg') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<meta name="generator" content="Hexo 5.4.0"></head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_coy.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">NIUOKE</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/about/" title="简历">
		                简历
		            </a>
		        </li>
		        
		        <li>
		            <a href="/group/" title="团队">
		                团队
		            </a>
		        </li>
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="标签">
		                标签
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
                    <li>
                        <a title="github" href="https://github.com/miccall" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="500px" href="http://500px.com" target="_blank" rel="noopener">
                            <i class="icon fa fa-500px"></i>
                        </a>
                    </li>
                    
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(https://i.loli.net/2019/04/15/5cb48b98c423f.jpg);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >自己总结的面试题</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <h1 id="一、HTML5-CSS3"><a href="#一、HTML5-CSS3" class="headerlink" title="一、HTML5+CSS3"></a>一、HTML5+CSS3</h1><h3 id="除flex布局方式外，还有哪些布局"><a href="#除flex布局方式外，还有哪些布局" class="headerlink" title="除flex布局方式外，还有哪些布局"></a>除flex布局方式外，还有哪些布局</h3><ul>
<li>瀑布流布局<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44135121/article/details/98629830">https://blog.csdn.net/weixin_44135121/article/details/98629830</a></li>
<li>流式布局<ul>
<li>左侧固定,右侧自适应</li>
<li>右侧固定左侧自适应</li>
<li>两侧固定,中间自适应(圣杯布局)</li>
<li>等分布局</li>
</ul>
</li>
<li>float布局<ul>
<li>圣杯布局</li>
<li>双飞翼布局</li>
</ul>
</li>
<li>响应式布局<ul>
<li>meta 标签</li>
<li>使用 rem</li>
<li>media query（媒体查询）</li>
</ul>
</li>
<li>grid布局</li>
</ul>
<h3 id="grid布局"><a href="#grid布局" class="headerlink" title="grid布局"></a>grid布局</h3><ul>
<li><p>概念</p>
<ul>
<li>Grid 布局则是将容器划分成”行”和”列”，产生单元格，然后指定”项目所在”的单元格，可以看作是<strong>二维布局</strong>。</li>
<li>容器里面的水平区域称为”行”（row），垂直区域称为”列”（column）。</li>
<li>行和列的交叉区域，称为”单元格”（cell）。</li>
<li>划分网格的线，称为”网格线”（grid line）。</li>
</ul>
</li>
<li><p>容器属性</p>
<ul>
<li>display 属性<ul>
<li><code>display: grid</code>——块级元素</li>
<li>``display: inline-grid`——行内块元素</li>
</ul>
</li>
<li>grid-template-columns 属性， grid-template-rows 属性<ul>
<li>grid-template-columns:100px 100px 100px;</li>
<li>grid-template-rows:100px 100px 100px;<ul>
<li><strong>repeat()</strong><ul>
<li>grid-template-columns:repeat(3, 33.33%);——定义了3列</li>
<li>grid-template-rows:repeat(3, 33.33%);——定义了3列</li>
<li>grid-template-columns:repeat(2, 100px 20px 80px);——定义了6列</li>
</ul>
</li>
<li><strong>auto-fill 关键字</strong><ul>
<li>grid-template-columns: repeat(auto-fill, 100px);——表示每列宽度<code>100px</code>，然后自动填充，直到容器不能放置更多的列。</li>
</ul>
</li>
<li><strong>fr 关键字</strong><ul>
<li><code>fr</code>关键字（fraction 的缩写，意为”片段”）。两列的宽度分别为<code>1fr</code>和<code>2fr</code>，就表示后者是前者的两倍。</li>
<li>grid-template-columns: 1fr 1fr;——表示两个相同宽度的列。</li>
<li><code>fr</code>可以与绝对长度的单位结合使用</li>
<li>grid-template-columns: 150px 1fr 2fr;——第一列的宽度为150像素，第二列的宽度是第三列的一半。</li>
</ul>
</li>
<li><strong>minmax()</strong><ul>
<li><code>minmax()</code>函数产生一个长度范围，表示长度就在这个范围之中。它接受两个参数，分别为最小值和最大值。</li>
<li>grid-template-columns: 1fr 1fr minmax(100px, 1fr);——<code>minmax(100px, 1fr)</code>表示列宽不小于<code>100px</code>，不大于<code>1fr</code>。</li>
</ul>
</li>
<li><strong>auto 关键字</strong><ul>
<li><code>auto</code>关键字表示由浏览器自己决定长度。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>grid-row-gap 属性， grid-column-gap 属性， grid-gap 属性<ul>
<li><code>rid-row-gap</code>属性设置行与行的间隔（行间距），<code>grid-column-gap</code>属性设置列与列的间隔（列间距）。<ul>
<li>grid-row-gap: 20px;</li>
<li>grid-column-gap: 20px;</li>
</ul>
</li>
<li><code>grid-gap</code>属性是<code>grid-column-gap</code>和<code>grid-row-gap</code>的合并简写形式，语法如下。<ul>
<li>grid-gap: <grid-row-gap> <grid-column-gap>;</li>
<li>grid-gap: 20px 20px;</li>
</ul>
</li>
<li>根据最新标准，上面三个属性名的<code>grid-</code>前缀已经删除，<code>grid-column-gap</code>和<code>grid-row-gap</code>写成<code>column-gap</code>和<code>row-gap</code>，<code>grid-gap</code>写成<code>gap</code>。</li>
</ul>
</li>
<li>grid-template-areas 属性<ul>
<li>允许指定”区域”（area），一个区域由单个或多个单元格组成。<code>grid-template-areas</code>属性用于定义区域。</li>
<li>grid-template-areas: ‘a a a’——将九个格子划分成三个区域<pre><code>                                 &#39;b b b&#39;
                                 &#39;c c c&#39;
</code></pre>
</li>
</ul>
</li>
<li>grid-auto-flow 属性<ul>
<li>grid-auto-flow:row——先行后列</li>
<li>grid-auto-flow:column——先列后行</li>
<li>grid-auto-flow: row dense;——表示”先行后列”，并且尽可能紧密填满，尽量不出现空格。</li>
</ul>
</li>
<li>justify-items 属性， align-items 属性， place-items 属性<ul>
<li><code>justify-items</code>属性设置单元格内容的水平位置（左中右），<code>align-items</code>属性设置单元格内容的垂直位置（上中下）。<ul>
<li>justify-items: start | end | center | stretch;</li>
<li>align-items: start | end | center | stretch;<ul>
<li>stretch：拉伸，占满单元格的整个宽度（默认值）</li>
</ul>
</li>
</ul>
</li>
<li><code>place-items</code>属性是<code>align-items</code>属性和<code>justify-items</code>属性的合并简写形式。</li>
</ul>
</li>
<li>justify-content 属性， align-content 属性， place-content 属性<ul>
<li><code>justify-content</code>属性是整个内容区域在容器里面的水平位置（左中右），<code>align-content</code>属性是整个内容区域的垂直位置（上中下）。<ul>
<li>justify-content: start | end | center | stretch | space-around | space-between | space-evenly;</li>
<li>align-content: start | end | center | stretch | space-around | space-between | space-evenly;</li>
</ul>
</li>
<li><code>place-content</code>属性是<code>align-content</code>属性和<code>justify-content</code>属性的合并简写形式。</li>
</ul>
</li>
<li>grid-auto-columns 属性， grid-auto-rows 属性<ul>
<li><code>grid-auto-columns</code>属性和<code>grid-auto-rows</code>属性用来设置，浏览器自动创建的多余网格的列宽和行高。</li>
</ul>
</li>
</ul>
</li>
<li><p>项目属性</p>
<ul>
<li>grid-column-start 属性， grid-column-end 属性， grid-row-start 属性， grid-row-end 属性</li>
<li>grid-column 属性， grid-row 属性</li>
</ul>
</li>
</ul>
<h3 id="移动端是如何进行适配的"><a href="#移动端是如何进行适配的" class="headerlink" title="移动端是如何进行适配的"></a>移动端是如何进行适配的</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/36851344">https://zhuanlan.zhihu.com/p/36851344</a></p>
<ul>
<li><strong>meta viewport</strong></li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">width=device-width: 让当前viewport宽度等于设备的宽度</span><br><span class="line">user-scalable=no: 禁止用户缩放</span><br><span class="line">initial-scale=1.0: 设置页面的初始缩放值为不缩放</span><br><span class="line">maximum-scale=1.0: 允许用户的最大缩放值为1.0</span><br><span class="line">minimum-scale=1.0: 允许用户的最小缩放值为1.0</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>媒体查询（响应式）</strong></li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//格式一</span><br><span class="line"><span class="keyword">@media</span> （）<span class="keyword">and</span>（）&#123;&#125;</span><br><span class="line">//满足（）里的条件，就执行大括号里css的样式</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//格式二</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span><span class="attr">media</span>=<span class="string">&quot;(max-width:320px)&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>动态rem方案</strong></p>
<ul>
<li>1rem等于根元素html的font-size的值，那么可以调整根元素的font-size值来调整页面缩放后的各个元素的尺寸和定位。</li>
</ul>
</li>
<li><p><strong>对动态rem进行微调</strong></p>
</li>
<li><p><strong>其他补充</strong></p>
<ul>
<li><strong>px em rem vh vw的区别</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">px：表示像素</span><br><span class="line">em：一个字的高度 //1em == 自己font-size的值</span><br><span class="line">rem：root em // 根元素html的font-size</span><br><span class="line">vh：viewport height   视口高度=100vh</span><br><span class="line">vw：viewport width    视口宽度=100vw</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>百分比布局和整体缩放布局的区别</strong><ul>
<li>百分比布局：无法让高度跟着屏幕宽度改变而进行有比例的改变，高度和宽度无法做任何的配合；</li>
<li>整体缩放布局：一切单位以宽度为基准。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="img标签的间隙问题如何处理"><a href="#img标签的间隙问题如何处理" class="headerlink" title="img标签的间隙问题如何处理"></a>img标签的间隙问题如何处理</h3><ul>
<li>方法一：在img标签的父级元素上写：font-size:0；vertical-align：middle；</li>
<li>方法二：给img标签本身加上display：block（因为img是内联标签）</li>
</ul>
<h3 id="a标签href和target属性"><a href="#a标签href和target属性" class="headerlink" title="a标签href和target属性"></a>a标签href和target属性</h3><ul>
<li>herf用法<ul>
<li><strong>1.跳转到目标页面</strong></li>
<li><strong>2.锚链接</strong></li>
</ul>
</li>
<li>target属性<ul>
<li><strong>1.target属性值为_self</strong><ul>
<li>如果a标签中不设置target属性值，_self为这个属性的默认值，其作用是在当前页面跳转进行跳转。</li>
</ul>
</li>
<li><strong>2.target属性值为_blank</strong><ul>
<li>跳转在一个新打开、未命名的新页面。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="px、pt、em和rem"><a href="#px、pt、em和rem" class="headerlink" title="px、pt、em和rem"></a>px、pt、em和rem</h3><ul>
<li>pt<ul>
<li>点（Points），绝对长度单位。</li>
</ul>
</li>
<li>px<ul>
<li>px像素（Pixels）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的。</li>
<li>特点：<ul>
<li><ol>
<li>IE无法调整那些使用px作为单位的字体大小；</li>
</ol>
</li>
<li><ol start="2">
<li>国外的大部分网站能够调整的原因在于其使用了em或rem作为字体单位；</li>
</ol>
</li>
<li><ol start="3">
<li>Firefox能够调整px和em，rem，但是96%以上的中国网民使用IE浏览器(或内核)。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>em<ul>
<li>em是相对长度单位。相对于当前对象内文本的字体尺寸。<ul>
<li><ol>
<li>em的值并不是固定的；</li>
</ol>
</li>
<li><ol start="2">
<li>em会继承父级元素的字体大小。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>rem<ul>
<li>rem是CSS3新增的一个相对单位，相对于根元素(即html元素)font-size计算值的倍数。</li>
<li>rem可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。</li>
</ul>
</li>
</ul>
<h3 id="产生点击穿透，该如何解决"><a href="#产生点击穿透，该如何解决" class="headerlink" title="产生点击穿透，该如何解决"></a>产生点击穿透，该如何解决</h3><ul>
<li>方法一：设置定时器</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> $(<span class="string">&#x27;.mask&#x27;</span>).classList.add(<span class="string">&#x27;hide&#x27;</span>), <span class="number">300</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>方法二：添加阻止默认事件</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.preventDefault() <span class="comment">//阻止默认事件</span></span><br></pre></td></tr></table></figure>

<ul>
<li>方法三：事件向父级冒泡</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event.stopPropagation();</span><br></pre></td></tr></table></figure>



<h3 id="垂直居中的方法有哪些"><a href="#垂直居中的方法有哪些" class="headerlink" title="垂直居中的方法有哪些"></a>垂直居中的方法有哪些</h3><p>前提</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">html</span>,<span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>方法一：<strong>通过verticle-align:middle实现CSS垂直居中。</strong></li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//给当前元素设置</span><br><span class="line"><span class="selector-class">.ziji</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>:inline-block;</span><br><span class="line">    <span class="attribute">vertical-align</span>:middle;</span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure>

<ul>
<li>方法二：弹性盒<strong>通过父级display:flex+子级margin: auto;实现CSS垂直居中。</strong></li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.fuji</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>:flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.ziji</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>方法三：弹性盒<strong>父级元素</strong></li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.fuji</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>方法四：<strong>通过给父级添加伪元素:before实现CSS垂直居中。</strong></li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.fuji</span>:before&#123;</span><br><span class="line">    content:<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">display</span>:inline-block;</span><br><span class="line">    <span class="attribute">vertical-align</span>:middle;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>方法五：<strong>通过父元素display:table，子元素display:table-cell实现CSS垂直居中。</strong></li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.fuji</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:table;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.ziji</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:table-cell;</span><br><span class="line">    <span class="attribute">vertical-align</span>:middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>方法六：<strong>绝对定位+margin：auto，简单粗暴</strong></li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.ziji</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>方法七：<strong>已知子元素高度通过给子元素设置绝对定位+margin实现CSS垂直居中。</strong></li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.ziji</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin</span>: -<span class="number">150px</span> <span class="number">0</span> <span class="number">0</span> -<span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>方法八：<strong>未知父元素高度通过给父元素相对定位+子元素绝对定位+transform实现CSS垂直居中。</strong></li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.fuji</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>:relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.ziji</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>:<span class="built_in">translateY</span>(-<span class="number">50%</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>方法九：<strong>通过给子元素设置line-height=父元素高度实现CSS垂直居中。</strong></li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.fuji</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.ziji</span>&#123;</span><br><span class="line">    <span class="attribute">line-height</span>:<span class="number">300px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="position属性"><a href="#position属性" class="headerlink" title="position属性"></a>position属性</h3><table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">absolute</td>
<td align="left">生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</td>
</tr>
<tr>
<td align="left">fixed</td>
<td align="left">生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</td>
</tr>
<tr>
<td align="left">relative</td>
<td align="left">生成相对定位的元素，相对于其正常位置进行定位。因此，”left:20” 会向元素的 LEFT 位置添加 20 像素。</td>
</tr>
<tr>
<td align="left">static</td>
<td align="left">默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。</td>
</tr>
<tr>
<td align="left">inherit</td>
<td align="left">规定应该从父元素继承 position 属性的值。</td>
</tr>
<tr>
<td align="left">sticky</td>
<td align="left">生成黏性定位的元素，相对于页面视口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。但是各大浏览器对于sticky存在兼容问题，且js也可实现。</td>
</tr>
</tbody></table>
<p>sticky注意</p>
<ul>
<li>须指定 <code>top、right、bottom、left</code> 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。</li>
</ul>
<p>并且 <code>top</code> 和 <code>bottom</code> 同时设置时，<code>top</code> 生效的优先级高，<code>left</code> 和 <code>right</code> 同时设置时，<code>left</code> 的优先级高。</p>
<ul>
<li>设定为 <code>position:sticky</code> 元素的任意父节点的 <code>overflow</code> 属性必须是 <code>visible</code>，否则 <code>position:sticky</code> 不会生效。如果 <code>position:sticky</code> 元素的任意父节点定位设置为 <code>overflow:hidden</code>，则父容器无法进行滚动，所以 <code>position:sticky</code> 元素也不会有滚动然后固定的情况。如果 <code>position:sticky</code> 元素的任意父节点定位设置为 <code>position:relative | absolute | fixed</code>，则元素相对父元素进行定位，而不会相对 <code>viewport</code> 定位。</li>
<li>达到设定的阀值，也就是设定了 <code>position:sticky</code> 的元素表现为 <code>relative</code> 还是 <code>fixed</code>是根据元素是否达到设定了的阈值决定的。</li>
</ul>
<h3 id="H5新增了什么标签"><a href="#H5新增了什么标签" class="headerlink" title="H5新增了什么标签"></a>H5新增了什么标签</h3><ul>
<li><p>语义化标签</p>
<p>section、header、nav、article、aside、footer、figure、main、canvas、video、audio、source</p>
</li>
<li><p>智能表单——指type类型的不同</p>
<p>email、number、url、range、search、color、time、date、month、week</p>
</li>
<li><p>智能表单——新增属性</p>
<p>placeholder、autocomplete、Multiple、pattern、Datalist </p>
</li>
</ul>
<h3 id="less和sass的区别"><a href="#less和sass的区别" class="headerlink" title="less和sass的区别"></a>less和sass的区别</h3><p>css的缺点：</p>
<ul>
<li>语法不够强大，比如无法嵌套书写，导致模块化开发中需要书写很多重复的选择器；</li>
<li>没有变量和合理的样式复用机制，使得逻辑上相关的属性值必须以字面量的形式重复输出，导致难以维护。</li>
</ul>
<p>css预处理器：</p>
<ul>
<li>CSS 预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为 CSS 增加了一些编程的特性，将 CSS 作为目标生成文件，然后开发者就只要使用这种语言进行CSS的编码工作。</li>
<li>用一种专门的编程语言，进行 Web 页面样式设计，再通过编译器转化为正常的 CSS 文件，以供项目使用</li>
</ul>
<p>两者区别：</p>
<ul>
<li><p><strong>Less环境较Sass简单</strong></p>
<ul>
<li>Less基于JavaScript</li>
<li>Sass的安装需要安装Ruby环境</li>
</ul>
</li>
<li><p><strong>Less使用较Sass简单</strong></p>
</li>
<li><p><strong>从功能出发，Sass较Less略强大一些</strong></p>
<ul>
<li>①sass有变量和作用域。</li>
<li>②sass有函数的概念。</li>
<li>③进程控制。</li>
<li>④数据结构</li>
</ul>
</li>
<li><p><strong>Less与Sass处理机制不一样</strong></p>
<ul>
<li>Less是通过客户端处理</li>
<li>Sass是通过服务端处理</li>
</ul>
</li>
<li><p><strong>关于变量在Less和Sass中的唯一区别就是Less用@，Sass用$。</strong></p>
</li>
</ul>
<h1 id="二、javascript"><a href="#二、javascript" class="headerlink" title="二、javascript"></a>二、javascript</h1><h3 id="js中的数据类型"><a href="#js中的数据类型" class="headerlink" title="js中的数据类型"></a>js中的数据类型</h3><ul>
<li>基本数据类型（简单数据类型）：<ul>
<li>数值型——number</li>
<li>字符型——string</li>
<li>布尔型——boolean</li>
<li>未定型——undefined</li>
<li>空型——null</li>
</ul>
</li>
<li>引用数据类型（复杂数据类型）——Object：<ul>
<li>数组——Array</li>
<li>函数——Function</li>
<li>对象——Object</li>
</ul>
</li>
<li>区别<ul>
<li>内存分配：<ul>
<li>基本类型：存储在栈（stack）中，直接存储在<strong>变量访问的位置</strong>。</li>
<li>引用类型：存储在堆（heap）中的对象，<strong>存储在变量处的值是一个指针（point），指向存储对象的内存地址。</strong></li>
</ul>
</li>
<li>访问机制：<ul>
<li>基本类型：可直接访问到。</li>
<li>引用类型：不允许直接访问，首先得到该对象在堆内存中的地址，然后再按照这个地址去获得这个对象中的值，这就是<strong>按引用访问</strong>。</li>
</ul>
</li>
<li>复制变量：<ul>
<li>基本类型：可直接复制，<strong>两个变量是完全独立的，他们只是拥有相同的value而已</strong>。</li>
<li>引用类型：<ul>
<li>浅拷贝：把这个内存地址赋值给新变量，两个变量都指向了堆内存中的同一个对象，他们中任何一个作出的改变都会反映在另一个身上，相互影响。<strong>多了一个指针</strong></li>
<li>深拷贝：在堆中重新分配内存，拥有不同的地址，但是值是一样的，复制后的对象与原来的对象是完全隔离，互不影响。</li>
</ul>
</li>
</ul>
</li>
<li>参数传递：<ul>
<li>基本类型：把变量里的值传递给参数，之后参数和这个变量互不影响。</li>
<li>引用类型：传递的值是这个对象在堆内存中的内存地址。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="如何判断数据类型"><a href="#如何判断数据类型" class="headerlink" title="如何判断数据类型"></a>如何判断数据类型</h3><ul>
<li><p><strong>typeof</strong>  只能检测基本数据类型</p>
<ul>
<li>语法：typeof(你要检测的数据)</li>
<li>缺点：typeof不适合用于判断是否为数组。当使用typeof判断数组和对象的时候，都会返回object。</li>
</ul>
</li>
<li><p><strong>instanceof</strong>用于判断一个变量是否某个对象的实例。</p>
<ul>
<li>语法：arr instanceof Array</li>
<li>缺点：instanceof只能用来判断对象和函数，不能用来判断字符串和数字等。判断它是否为字符串和数字时，只会返回false。</li>
</ul>
</li>
<li><p><strong>constructor</strong></p>
<ul>
<li>constructor 属性返回对创建此对象的数组函数的引用。</li>
<li>语法：obj.constructor </li>
</ul>
</li>
<li><p><strong>Object.prototype.toString.call()</strong> 准确检测各种数据类型。<strong>保证兼容性</strong></p>
<ul>
<li>需要注意大小写</li>
</ul>
</li>
</ul>
<h3 id="数组的方法"><a href="#数组的方法" class="headerlink" title="数组的方法"></a>数组的方法</h3><ul>
<li><p>1、pop()把数组的最后一项删除了</p>
<ul>
<li>返回值 就是被删除的 那一项数据</li>
<li>会直接改变原数组                                </li>
</ul>
</li>
<li><p>2、push()给数组的末尾添加一项</p>
<ul>
<li>参数就是要追加的数据</li>
<li>返回值就是 改变后的数组的长度</li>
<li>会改变原数组</li>
</ul>
</li>
<li><p>3、shift()  删除数组的第 0 项</p>
<ul>
<li>返回值就是被删除的那一项</li>
<li>会改变原数组</li>
</ul>
</li>
<li><p>4、unshift()  向数组的开头添加一项数据</p>
<ul>
<li>返回值就是改变后的数组的长度</li>
<li>会改变原数组 </li>
</ul>
</li>
<li><p>5、indexOf()   检测数组里面有没有某一项数据</p>
<ul>
<li>返回值：有就返回对应的下标 没有就返回 -1 </li>
<li>不会改变原数组</li>
</ul>
</li>
<li><p>6、concat()   拼接数组</p>
<ul>
<li>参数:理论上是有无限个、也可拼接数组</li>
<li>返回值：就是拼接以后的另外的数组</li>
<li>不会改变原数组</li>
</ul>
</li>
<li><p>7、join()  加入  可以把一个数组转为 字符串  用你传入的符号 把数组的每一项拼接起来</p>
<ul>
<li>返回值就是 拼接好的另外的数组</li>
<li>不会改变原数组</li>
</ul>
</li>
<li><p>8、reverse()   反转 把一个数组 颠倒过来</p>
<ul>
<li>返回值就是改变后的新数组</li>
<li>直接改变原数组</li>
</ul>
</li>
<li><p>9、sort()   排序 </p>
<ul>
<li>语法:数组.sort()   sort 方法接收一个参数 这个参数是一个函数<ul>
<li>return a - b  升序</li>
<li>return b - a  降序</li>
</ul>
</li>
<li>返回值 就是排序好的数组</li>
<li>直接改变原数组</li>
</ul>
</li>
<li><p>10、splice()   截取数据</p>
<ul>
<li>语法：数组.splice(开始截取的位置,截取的个数)</li>
<li>第三个参数 就是把截取掉的数据替换了</li>
<li>返回值：截取的数组组成的一个新的数组</li>
<li>直接改变原数组</li>
</ul>
</li>
<li><p>11、forEach(function(item,index,source){})</p>
<ul>
<li>参数是一个函数 ，这个函数有三个参数</li>
<li>第一个就是数组的每一项  第二个参数就是索引  第三个参数就是 原始数据</li>
<li>没有返回值</li>
<li>forEach 有的时候会改变原始数据有的时候不会改变</li>
</ul>
</li>
<li><p>12、map(function(item,index,source){})</p>
<ul>
<li>参数是一个函数，这个函数有三个参数 </li>
<li>第一个就是数组的每一项  第二个参数就是索引  第三个参数就是 原始数据</li>
<li>这个函数里面要写 return return 后面跟的东西就是这个新的数组里面的每一项</li>
<li>返回值 是一个新的数组</li>
<li>当数组中元素是值类型，map不会改变原数组；当是引用类型，则可以改变原数组</li>
</ul>
</li>
<li><p>13、filter(function(item,index,source){})</p>
<ul>
<li>参数是一个函数，这个函数有三个参数</li>
<li>第一个就是数组的每一项  第二个参数就是索引  第三个参数就是 原始数据</li>
<li>返回值是一个新的数组 里面是满足条件的每一项</li>
<li>不会改变原数组</li>
</ul>
</li>
<li><p>14、every(function(item,index,source){})</p>
<ul>
<li>参数是一个函数，这个函数有三个参数</li>
<li>第一个就是数组的每一项  第二个参数就是索引  第三个参数就是 原始数据</li>
<li>每一项都满足条件 就返回 true 否则 false</li>
</ul>
</li>
<li><p>15、some(function(item,index,source){})</p>
<ul>
<li>参数是一个函数 ，这个函数有三个参数</li>
<li>第一个就是数组的每一项  第二个参数就是索引  第三个参数就是 原始数据</li>
<li>检测数组里面有没符合条件的项 return 后面写的就是条件</li>
<li>只要数组里面有一个满足条件了 最后的返回值就是 true 只有所有的都不满足条件 就返回 false</li>
<li>返回值是一个布尔值</li>
</ul>
</li>
</ul>
<h3 id="字符串的方法"><a href="#字符串的方法" class="headerlink" title="字符串的方法"></a>字符串的方法</h3><ul>
<li><p>1、substring()  截取</p>
<ul>
<li>第一个参数是开始截取的位置 第二个参数是结束截取的位置  包前不包后</li>
<li>不会改变原始数据</li>
</ul>
</li>
<li><p>2、substr()  截取字符串</p>
<ul>
<li>第一个参数是开始截取的位置 第二个参数是截取的个数</li>
<li>不会改变原始数据</li>
</ul>
</li>
<li><p>3、toLowerCase()  把大写字符串转为 小写字母</p>
<ul>
<li>不会改变原始数据</li>
</ul>
</li>
<li><p>4、toUpperCase()  把小写字符串转为 大写字母</p>
<ul>
<li>不会改变原始数据</li>
</ul>
</li>
<li><p>5、<strong>indexOf()</strong>  检测字符串里面有没有某一个字符**</p>
<ul>
<li>返回值 有的话就返回下标 没有就返回 -1</li>
<li>不会改变原始数据</li>
</ul>
</li>
<li><p>6、charAt()   用来查询对应下标的字符</p>
<ul>
<li>参数就是一个索引</li>
<li>返回值 对应的字符 </li>
<li>不会改变原始数据</li>
</ul>
</li>
<li><p>7、charCodeAt()  用来查询对应下标字符的编码</p>
</li>
<li><p>8、<strong>split()</strong>  以一个特定的符号把一个字符串分割成数组 </p>
<ul>
<li>如果参数是一个空字符串 那就是每一个字符都分隔开</li>
</ul>
</li>
<li><p>9、<strong>replace()</strong>   替换</p>
<ul>
<li>第一个参数就是要被替换的字符 第二个参数就是要用什么字符来替换</li>
</ul>
</li>
</ul>
<h3 id="跨域问题的解决办法"><a href="#跨域问题的解决办法" class="headerlink" title="跨域问题的解决办法"></a>跨域问题的解决办法</h3><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000011145364">https://segmentfault.com/a/1190000011145364</a></p>
<p><strong>同源策略</strong>/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指**”协议+域名+端口”**三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p>
<ul>
<li>方法一：<strong>Jsonp</strong><ul>
<li>通过动态创建script，再请求一个带参网址实现跨域通信。</li>
<li>缺点：仅支持 GET 方法</li>
</ul>
</li>
<li>方法二： <strong>Node正向代理</strong><ul>
<li>node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。</li>
<li>缺点：无法传递 cookie</li>
</ul>
</li>
<li>方法三：<strong>nginx反向代理接口跨域</strong><ul>
<li>过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。</li>
</ul>
</li>
<li>方法四： <strong>跨域资源共享（CORS）</strong><ul>
<li>这个方法是后端解决跨域的方法之一</li>
<li>缺点：一般情况下后端接口是不会开启这个跨域头的，除非是一些与用户无关的不太重要的接口。</li>
</ul>
</li>
</ul>
<h3 id="js的兼容问题"><a href="#js的兼容问题" class="headerlink" title="js的兼容问题"></a>js的兼容问题</h3><ul>
<li><p>获取元素的非行间样式（具体用法在day10.05）</p>
<ul>
<li>getComputedStyle()————IE9及以上支持 </li>
<li>currentStyle————chrome 不支持</li>
</ul>
</li>
<li><p>关于获取滚动条距离而出现的问题</p>
<ul>
<li>document.documentElement.scrollTop——FF:</li>
<li>document.body.scrollTop——IE,Chrome:     </li>
</ul>
</li>
<li><p>在做事件处理时，用于区分IE和其他浏览器事件对象</p>
<ul>
<li>e = e || window.event  </li>
<li>e——非 IE 使用</li>
<li>window.event——IE 使用</li>
</ul>
</li>
<li><p>给一个元素绑定多个事件———添加事件监听（具体day12.06）</p>
<ul>
<li>addEventListener——IE9及以上支持 </li>
<li>attachEvent———IE8</li>
</ul>
</li>
<li><p>解绑事件（具体day12.07）</p>
<ul>
<li>removeEventListener(事件类型,事件处理函数)——IE9及以上支持</li>
<li>detachEvent(on + 事件类型,事件处理函数)———IE8</li>
</ul>
</li>
<li><p>阻止冒泡（具体day13.02）</p>
<ul>
<li>e.stopPropagation()——非 IE 使用</li>
<li>e.cancelBubble = true——IE 使用</li>
</ul>
</li>
<li><p>阻止默认事件（具体day13.05）</p>
<ul>
<li>e.preventDefault()——非 IE 使用</li>
<li>e.returnValue = false——IE 使用</li>
</ul>
</li>
<li><p>事件委派的目标源元素</p>
<ul>
<li>target——非 IE 使用 </li>
<li>srcElement——IE使用 </li>
</ul>
</li>
</ul>
<h3 id="二分法查找的逻辑思路"><a href="#二分法查找的逻辑思路" class="headerlink" title="二分法查找的逻辑思路"></a>二分法查找的逻辑思路</h3><ul>
<li><p>思路：</p>
<ul>
<li>首先，从有序数组的中间的元素开始搜索，如果该元素正好是目标元素(即要查找的元素），则搜索过程结束，否则进行下一步。</li>
<li>如果目标元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半区域查找，然后重复第一步的操作。</li>
<li>如果某一步数组为空，则表示找不到目标元素</li>
</ul>
</li>
<li><p>代码实现</p>
<ul>
<li>非递归：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">binary_search</span>(<span class="params">arr, key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> high = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">        <span class="keyword">let</span> mid = <span class="built_in">parseInt</span>((high + low) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(key === arr[mid])&#123;</span><br><span class="line">            <span class="keyword">return</span>  mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key &gt; arr[mid])&#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key &lt; arr[mid])&#123;</span><br><span class="line">            high = mid -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>递归：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">binary_search</span>(<span class="params">arr,low, high, key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &gt; high)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> mid = <span class="built_in">parseInt</span>((high + low) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(arr[mid] === key)&#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; key)&#123;</span><br><span class="line">        high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> binary_search(arr, low, high, key);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; key)&#123;</span><br><span class="line">        low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> binary_search(arr, low, high, key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包就是能够读取其他函数内部变量的函数。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p>
<p>函数的嵌套形成闭包，闭包包括函数本身已经它的外部作用域使用闭包可以形成独立的空间，延长变量的生命周期，报存中间状态值</p>
<p>闭包用的多的两个作用：读取函数内部的变量值；让这些变量值始终保存着(在内存中)。 同时需要注意的是：闭包慎用，不滥用，不乱用，由于函数内部的变量都被保存在内存中，会导致内存消耗大。</p>
<p>闭包让你可以在一个内层函数中访问到其外层函数的作用域。</p>
<h3 id="浏览器如何保存数据，及他们的区别"><a href="#浏览器如何保存数据，及他们的区别" class="headerlink" title="浏览器如何保存数据，及他们的区别"></a>浏览器如何保存数据，及他们的区别</h3><p>该题目在问<strong>cookies</strong>，<strong>sessionStorage</strong> 和<strong>localStorage</strong> 的区别？</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">相同点：</span><br><span class="line">	都是保存在浏览器端，且同源的。</span><br><span class="line">生命周期：</span><br><span class="line">	cookie：可设置失效时间，没有设置的话，默认是关闭浏览器后失效</span><br><span class="line">	localStorage：除非被手动清除，否则将会永久保存。</span><br><span class="line">	sessionStorage： 仅在当前网页会话下有效，关闭页面或浏览器后就会被清除。</span><br><span class="line">存放数据大小：</span><br><span class="line">	cookie：4KB左右</span><br><span class="line">	localStorage和sessionStorage：可以保存5MB的信息。</span><br><span class="line">http请求：</span><br><span class="line">	cookie：每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题</span><br><span class="line">	localStorage和sessionStorage：仅在客户端（即浏览器）中保存，不参与和服务器的通信</span><br><span class="line">易用性：</span><br><span class="line">	cookie：需要程序员自己封装，源生的Cookie接口不友好</span><br><span class="line">	localStorage和sessionStorage：源生接口可以接受，亦可再次封装来对Object和Array有更好的支持</span><br><span class="line">作用域不同：</span><br><span class="line">	不同浏览器无法共享localStorage或sessionStorage中的信息。</span><br><span class="line">	相同浏览器的不同页面间可以共享相同的localStorage（页面属于相同域名和端口）</span><br><span class="line">	不同页面或标签页间无法共享sessionStorage的信息</span><br></pre></td></tr></table></figure>



<h3 id="前端一般都从哪些方面进行优化"><a href="#前端一般都从哪些方面进行优化" class="headerlink" title="前端一般都从哪些方面进行优化"></a>前端一般都从哪些方面进行优化</h3><p>雅虎前端优化35条<a target="_blank" rel="noopener" href="https://www.cnblogs.com/xianyulaodi/p/5755079.html">https://www.cnblogs.com/xianyulaodi/p/5755079.html</a></p>
<ul>
<li><p>1、尽量减少 HTTP 请求：CSS Sprites, JS、CSS 源码压缩、图片大小控制合适；网页Gzip，CDN 托管，data 缓存 ，图片服务器。</p>
</li>
<li><p>2、使用浏览器缓存</p>
</li>
<li><p>3、使用压缩组件</p>
</li>
<li><p>4、图片、JS 的预载入、将样式表放在顶部，将脚本放在底部 加上时间戳</p>
</li>
<li><p>5、 避免在页面的主体布局中使用 table，table 要等其中的内容完全下载之后才会显示出来，显示比 div+css 布局慢。</p>
</li>
<li><p>6、用innerHTML 代替DOM 操作，减少 DOM 操作次数，优化 javascript 性能。</p>
</li>
<li><p>7、使用外部的 JS 和 CSS</p>
</li>
<li><p>8、精简代码</p>
</li>
<li><p>9、前端模板 JS+数据，减少由于 HTML 标签导致的带宽浪费，前端用变量保存 AJAX请求结果，每次操作本地变量，不用请求，减少请求次数</p>
</li>
<li><p>10、当需要设置的样式很多时设置 className 而不是直接操作 style。</p>
</li>
<li><p>11、少用全局变量、缓存DOM 节点查找的结果。减少 IO 读取操作。</p>
</li>
<li><p>12、避免使用 CSS Expression（css 表达式)又称Dynamic properties(动态属性)。</p>
</li>
</ul>
<h3 id="ajax获取数据的步骤"><a href="#ajax获取数据的步骤" class="headerlink" title="ajax获取数据的步骤"></a>ajax获取数据的步骤</h3><ol>
<li> 创建 XMLHttpRequest 对象,也就是创建一个异步调用对象</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xmlHttpRequest  = <span class="keyword">new</span> XMLHttpRequest();</span><br></pre></td></tr></table></figure>

<ol start="2">
<li> 创建一个新的 HTTP 请求,并指定该 HTTP 请求的方法、URL 及验证信息</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">xmlHttpRequest.open(method,URL,flag,name,password);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">method：该参数用于指定HTTP的请求方法，一共有get、post、head、put、delete五种方法，常用的方法为get和post。</span></span><br><span class="line"><span class="comment">URL：该参数用于指定HTTP请求的URL地址，可以是绝对URL，也可以是相对URL。</span></span><br><span class="line"><span class="comment">flag：该参数为可选，参数值为布尔型。该参数用于指定是否使用异步方式。true表示异步、false表示同步，默认为true。</span></span><br><span class="line"><span class="comment">name：该参数为可选参数，用于输入用户名。如果服务器需要验证，则必须使用该参数。</span></span><br><span class="line"><span class="comment">password：该参数为可选，用于输入密码。若服务器需要验证，则必须使用该参数。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li> 设置响应 HTTP 请求状态变化的函数</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置当XMLHttpRequest对象状态改变时调用的函数，注意函数名后面不要添加小括号</span></span><br><span class="line">xmlHttpRequest.onreadystatechange = getData;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//定义函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//判断XMLHttpRequest对象的readyState属性值是否为4，如果为4表示异步调用完成</span></span><br><span class="line">    <span class="keyword">if</span>(xmlHttpRequest.readyState == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="comment">//设置获取数据的语句</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li> 发送 HTTP 请求</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get 不需要传递参数</span></span><br><span class="line">xmlHttpRequest.send(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// post 需要传递参数</span></span><br><span class="line">xmlHttpRequest.send(<span class="string">&quot;name=jay&amp;age=18&quot;</span>)</span><br></pre></td></tr></table></figure>

<ol start="5">
<li> 获取异步调用返回的数据</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置当XMLHttpRequest对象状态改变时调用的函数，注意函数名后面不要添加小括号</span></span><br><span class="line">xmlHttpRequest.onreadystatechange = getData;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//定义函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//判断XMLHttpRequest对象的readyState属性值是否为4，如果为4表示异步调用完成</span></span><br><span class="line">    <span class="keyword">if</span>(xmlHttpRequest.readyState==<span class="number">4</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(xmlHttpRequest.status == <span class="number">200</span> || xmlHttpRequest.status == <span class="number">0</span>)&#123;<span class="comment">//设置获取数据的语句</span></span><br><span class="line">            <span class="built_in">document</span>.write(xmlHttpRequest.responseText);<span class="comment">//将返回结果以字符串形式输出</span></span><br><span class="line">            <span class="comment">//docunment.write(xmlHttpRequest.responseXML);//或者将返回结果以XML形式输出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li> 使用 JavaScript 和DOM 实现局部刷新</li>
</ol>
<ul>
<li>在通过Ajax的异步调用获得服务器端数据之后，可以使用JavaScript或DOM来将网页中的数据进行局部更新。</li>
</ul>
<h3 id="Promise是否了解"><a href="#Promise是否了解" class="headerlink" title="Promise是否了解"></a>Promise是否了解</h3><p><strong>Promise</strong> 对象用于表示一个异步操作的最终完成 (或失败)及其结果值。</p>
<p>一个 <code>Promise</code> 对象代表一个在这个 promise 被创建出来时不一定已知的值。它让您能够把异步操作最终的成功返回值或者失败原因和相应的处理程序关联起来。 这样使得异步方法可以像同步方法那样返回值：异步方法并不会立即返回最终的值，而是会返回一个 <em>promise对象</em>，以便在未来某个时候把值交给使用者。</p>
<p>一个 <code>Promise</code> 必然处于以下几种状态之一：</p>
<ul>
<li><em>待定（pending）</em>: 初始状态，既没有被兑现，也没有被拒绝。</li>
<li><em>已兑现（fulfilled、resolved）</em>: 意味着操作成功完成。</li>
<li><em>已拒绝（rejected）</em>: 意味着操作失败。</li>
</ul>
<h3 id="Promise的使用"><a href="#Promise的使用" class="headerlink" title="Promise的使用"></a>Promise的使用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 一段耗时的异步操作</span></span><br><span class="line">    resolve(<span class="string">&#x27;成功&#x27;</span>) <span class="comment">// 数据处理完成</span></span><br><span class="line">    <span class="comment">// reject(&#x27;失败&#x27;) // 数据处理出错</span></span><br><span class="line">  &#125;</span><br><span class="line">).then(</span><br><span class="line">  <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;<span class="built_in">console</span>.log(res)&#125;,  <span class="comment">// 成功</span></span><br><span class="line">  <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;<span class="built_in">console</span>.log(err)&#125; <span class="comment">// 失败</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>resolve作用</strong>是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；<br><strong>reject作用</strong>是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>
</li>
<li><p><strong>Promise.resolve(value) 方法</strong></p>
<p>返回一个状态由给定value决定的Promise对象。如果该值是<em>thenable(即，带有then方法的对象)<em>，返回的Promise对象的最终状态由then方法执行决定；否则的话</em>(该value为空，基本类型或者不带then方法的对象)</em>,返回的Promise对象状态为fulfilled，并且将该value传递给对应的then方法。通常而言，如果您不知道一个值是否是Promise对象，使用Promise.resolve(value) 来返回一个Promise对象,这样就能将该value以Promise对象形式使用。</p>
<ul>
<li>value:成功的数据或promise对象</li>
<li>说明:返回一个成功/失败的promise对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span> (<span class="params">s</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//输出结果：Hello</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>Promise.reject(reason)方法</strong></p>
<p>返回一个状态为失败的Promise对象，并将给定的失败信息传递给对应的处理方法</p>
<ul>
<li>reason:失败的原因</li>
<li>说明:返回一个失败的promise对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.reject(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">p.then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span> (<span class="params">s</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//输出结果：出错了</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>Promise.all(promises) 批量执行</strong></p>
<p>Promise.all([p1, p2, p3])用于将多个promise实例，包装成一个新的Promise实例，返回的实例就是普通的promise</p>
<ul>
<li>promises:包含n个promise的数组</li>
<li>说明:返回一个新的promise，只有所有的 promise都成功才成功，只要有任何一个失败，该Promise失败，返回值是第一个失败的子Promise结果</li>
</ul>
</li>
<li><h5 id="Promise-race-promises-类似于Promise-all-，区别在于它有任意一个完成就算完成"><a href="#Promise-race-promises-类似于Promise-all-，区别在于它有任意一个完成就算完成" class="headerlink" title="Promise.race(promises) 类似于Promise.all() ，区别在于它有任意一个完成就算完成"></a>Promise.race(promises) 类似于Promise.all() ，区别在于它有任意一个完成就算完成</h5><p>当promises参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象。</p>
<ul>
<li>promises:包含n个promise的数组</li>
<li>说明:返回一个新的promise，第一个完成的promise的结果状态就是最终的结果状态</li>
</ul>
</li>
</ul>
<h3 id="aixos"><a href="#aixos" class="headerlink" title="aixos"></a>aixos</h3><ul>
<li>axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端。简单的理解就是ajax的封装</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">            <span class="attr">url</span>: <span class="string">&#x27;/getUsers&#x27;</span>,</span><br><span class="line">            <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">            <span class="attr">responseType</span>: <span class="string">&#x27;json&#x27;</span>, <span class="comment">// 默认的</span></span><br><span class="line">            <span class="attr">data</span>: &#123;</span><br><span class="line">                <span class="comment">//&#x27;a&#x27;: 1,</span></span><br><span class="line">                <span class="comment">//&#x27;b&#x27;: 2,</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(response);</span><br><span class="line">            <span class="built_in">console</span>.log(response.data);</span><br><span class="line">        &#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(error);</span><br><span class="line">            &#125;)</span><br><span class="line">原文链接：https:<span class="comment">//blog.csdn.net/qq_42942555/article/details/88400721</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>特征：</p>
<ul>
<li>从浏览器中创建 XMLHttpRequest</li>
<li>从 node.js 发出 http 请求</li>
<li>支持 Promise API</li>
<li>拦截请求和响应</li>
<li>转换请求和响应数据</li>
<li>取消请求</li>
<li>自动转换JSON数据</li>
</ul>
</li>
<li><p>拦截器</p>
</li>
</ul>
<p>在请求或响应被 then 或 catch 处理前拦截它们。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加请求拦截器</span></span><br><span class="line">axios.interceptors.request.use(<span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在发送请求之前做些什么</span></span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对请求错误做些什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">  &#125;);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 添加响应拦截器</span></span><br><span class="line">axios.interceptors.response.use(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对响应数据做点什么</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对响应错误做点什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">  &#125;);</span><br><span class="line">原文链接：https:<span class="comment">//blog.csdn.net/gao_xu_520/article/details/79726298</span></span><br></pre></td></tr></table></figure>



<h3 id="数组的拷贝"><a href="#数组的拷贝" class="headerlink" title="数组的拷贝"></a>数组的拷贝</h3><p>【js基础】深浅拷贝<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/26282765">https://zhuanlan.zhihu.com/p/26282765</a></p>
<p>对于<strong>基本数据类型</strong>，存储的方式是<code>键—值</code>存在栈中，对于<strong>引用数据类型</strong>，存储的方式是<code>键—引用地址</code>存在栈中，引用地址对应的<code>值</code>存在堆中。下图为引用数据类型的存储方式</p>
<p><img src="https://pic1.zhimg.com/80/v2-7e50dbaf6db560ae52a00acaf36e0ac0_720w.png" alt="img"></p>
<ul>
<li>浅拷贝：仅仅是复制了引用（地址），原来的变量和新的变量指向同一个东西，彼此之间的操作会互相影响。<ul>
<li>简单的复制语句</li>
<li>Object.assign()</li>
</ul>
</li>
<li>深拷贝：在堆中重新分配内存，拥有不同的地址，但是值是一样的，复制后的对象与原来的对象是完全隔离，互不影响。<ul>
<li>array.slice() ——截取数组</li>
<li>array.concat() ——连接数组</li>
<li>for 循环实现数组的深拷贝</li>
<li>JSON 对象的 parse 和 stringify</li>
<li>ES6扩展运算符实现数组的深拷贝（…）</li>
</ul>
</li>
</ul>
<h3 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h3><ul>
<li>普通函数调用：函数名()  this =&gt; window</li>
<li>***.函数名()  this =&gt; . 前面的那个东西（对象方法调用， 此时 this 指向 该方法所属的对象）</li>
<li>事件绑定函数  this =&gt;  事件源</li>
<li>定时器 this =&gt; window</li>
<li>函数自调用 this =&gt; window</li>
<li>构造函数调用， 此时 this 指向 实例对象</li>
</ul>
<h3 id="改变this指向"><a href="#改变this指向" class="headerlink" title="改变this指向"></a>改变this指向</h3><p>只是改变普通函数的 this 指向</p>
<ul>
<li><p><strong>call()</strong></p>
<ul>
<li>第一个参数就是 this 指向</li>
<li>第n个参数</li>
<li>立即调用函数</li>
<li>fn.call(obj,123,456)</li>
</ul>
</li>
<li><p><strong>apply()</strong></p>
<ul>
<li>第一个参数也是 this 指向</li>
<li>第二个参数 是一个数组 数组里面的每一项就是分别给函数传参</li>
<li>立即调用函数</li>
<li>fn.apply(obj,[123,456])</li>
</ul>
</li>
<li><p><strong>bind()</strong></p>
<ul>
<li>第一个参数是 this 指向</li>
<li>不会立即调用函数 会返回一个已经改变了 this 指向的新的函数</li>
<li>fn.bind(obj)</li>
</ul>
</li>
</ul>
<h3 id="三大系列"><a href="#三大系列" class="headerlink" title="三大系列"></a>三大系列</h3><ul>
<li>client<ul>
<li>clientWidth    clientHeight    获取的是元素 内容 + padding</li>
<li>clientLeft    clientTop    获取的是元素左边框和上边框的宽度</li>
<li>clientX    clientY    光标到可视窗口左边和上边的距离</li>
</ul>
</li>
<li>offset<ul>
<li>offsetWidth offsetHeight    获取的是元素内容 + padding + border</li>
<li>offsetLeft   offsetTop<ul>
<li>没有定位  元素相对于 页面 左边和上边的距离</li>
<li>有定位  元素相对于 有定位的父级元素左边和上边的距离</li>
</ul>
</li>
<li>offsetX  offsetY  光标到当前元素左边和上边的距离</li>
<li>offsetParent   有定位的父元素</li>
</ul>
</li>
<li>page<ul>
<li>pageX pageY   光标到页面左边和上边的距离</li>
</ul>
</li>
</ul>
<h3 id="HTTP的请求头有哪些"><a href="#HTTP的请求头有哪些" class="headerlink" title="HTTP的请求头有哪些"></a>HTTP的请求头有哪些</h3><p>HTTP的头域包括通用头、请求头、响应头和实体头四个部分。每个头域由一个域名，冒号(:)和域值三部分组成。</p>
<ul>
<li><p><strong>通用</strong>头部：是客户端和服务器都可以使用的头部，可以在客户端、服务器和其他应用程序之间提供一些非常有用的通用功能，如Date头部。</p>
</li>
<li><p><strong>请求</strong>头部：是请求报文特有的，它们为服务器提供了一些额外信息，比如客户端希望接收什么类型的数据，如Accept头部。</p>
</li>
<li><p><strong>响应</strong>头部：便于客户端提供信息，比如，客服端在与哪种类型的服务器进行交互，如Server头部。</p>
</li>
<li><p><strong>实体</strong>头部：指的是用于应对实体主体部分的头部，比如，可以用实体头部来说明实体主体部分的数据类型，如Content-Type头部。</p>
</li>
</ul>
<h3 id="HTTP-状态码有哪些？分别代表是什么意思？"><a href="#HTTP-状态码有哪些？分别代表是什么意思？" class="headerlink" title="HTTP 状态码有哪些？分别代表是什么意思？"></a>HTTP 状态码有哪些？分别代表是什么意思？</h3><ul>
<li><p><strong>1开头</strong>：（被接受，需要继续处理。）这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。</p>
<ul>
<li><code>100 </code>Continue 继续，一般在发送 post 请求时已发送了 http header 之后服务端将返回此信息，表示确认，之后发送具体参数信息</li>
</ul>
</li>
<li><p><strong>2开头</strong>: （请求成功）这一类型的状态码，代表请求已成功被服务器接收、理解、并接受.</p>
<ul>
<li><code>200</code> OK 正常返回信息</li>
<li><code>201</code> Created 请求成功并且服务器创建了新的资源</li>
<li><code>202</code> Accepted 服务器已接受请求，但尚未处理</li>
</ul>
</li>
<li><p>**3开头 **:（请求被重定向）这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的 location 域中指明。</p>
<ul>
<li><code>301</code> Moved Permanentiy 请求的网页已永久移动到新位置</li>
<li><code>302 </code>Found 临时性重定向</li>
<li><code>303 </code>See Other 临时性重定向，且总是使用 GET 请求新的 URL</li>
<li><code>304</code> Not Modified 自从上次请求后，请求的网页未修改过</li>
</ul>
</li>
<li><p><strong>4开头</strong>：（请求错误）这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个 HEAD 请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。</p>
<ul>
<li><code>400</code> Bad Request 服务端无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求</li>
<li><code>401</code> Unauthorized 请求未授权</li>
<li><code>403</code> Forbidden 禁止访问</li>
<li><code>404</code> Not Found 找不到如何与 URL 相匹配的资源</li>
</ul>
</li>
<li><p><strong>5开头</strong>：（服务器错误）这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个HEAD 请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。</p>
<ul>
<li><code>500</code> Internal Server Error 最常见的服务器端错误</li>
<li><code>503</code> Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）</li>
</ul>
</li>
</ul>
<h3 id="var-let-const-的区别"><a href="#var-let-const-的区别" class="headerlink" title="var let const 的区别"></a>var let const 的区别</h3><ul>
<li><p>var与let、const的区别</p>
<ul>
<li>作用域：<ul>
<li>var：全局作用域——window对象的属性</li>
<li>let、const：在块级作用域中起作用</li>
</ul>
</li>
<li>变量提升——变量可以在声明之前使用<ul>
<li>var：存在</li>
<li>let、const：不存在</li>
</ul>
</li>
<li>重复声明：<ul>
<li>var：允许</li>
<li>let、const：不允许</li>
</ul>
</li>
</ul>
</li>
<li><p>let与const的区别</p>
<ul>
<li>let是变量、const是常量</li>
<li>重新赋值：<ul>
<li>let：允许</li>
<li>const：不允许</li>
</ul>
</li>
<li>声明与赋值的顺序：<ul>
<li>let：可以先声明后赋值</li>
<li>const：必须在声明的时候就赋值</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="事件冒泡、事件捕获及阻止"><a href="#事件冒泡、事件捕获及阻止" class="headerlink" title="事件冒泡、事件捕获及阻止"></a>事件冒泡、事件捕获及阻止</h3><p>两个概念都是为了解决页面中<strong>事件流</strong>（事件发生顺序）的问题。</p>
<ul>
<li>事件冒泡<ul>
<li>概念：事件会从最内层的元素开始发生，一直向上传播，直到document对象。</li>
</ul>
</li>
<li>事件捕获<ul>
<li>事件冒泡相反，事件会从最外层开始发生，直到最具体的元素。</li>
</ul>
</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/16/16a2654b0dd928ef?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>1-5是捕获过程，5-6是目标阶段，6-10是冒泡阶段；</p>
<ul>
<li><p>addEventListener 的第三个参数</p>
<ul>
<li>语法：element.<strong>addEventListener</strong>(event, function, useCapture)<ul>
<li>event<ul>
<li>必须。字符串，指定事件名。</li>
<li>不要使用 “on” 前缀。 例如，使用 “click” ,而不是使用 “onclick”。</li>
</ul>
</li>
<li>function<ul>
<li>必须。指定要事件触发时执行的函数。</li>
<li>当事件对象会作为第一个参数传入函数。 事件对象的类型取决于特定的事件。例如， “click” 事件属于 MouseEvent(鼠标事件) 对象。</li>
</ul>
</li>
<li>useCapture<ul>
<li>可选。布尔值，指定事件是否在捕获或冒泡阶段执行。<ul>
<li>true - 事件句柄在<strong>捕获</strong>阶段执行（即在事件捕获阶段调用处理函数）</li>
<li>false-  默认。事件句柄在<strong>冒泡</strong>阶段执行（即表示在事件冒泡的阶段调用事件处理函数）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>阻止事件冒泡</p>
<ul>
<li>给子级加 event.stopPropagation( )</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;#div1&quot;</span>).mousedown(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> e=event||<span class="built_in">window</span>.event;</span><br><span class="line">    event.stopPropagation();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>在事件处理函数中返回 false</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;#div1&quot;</span>).mousedown(<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> e=e||<span class="built_in">window</span>.event;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>但是这两种方式是有区别的。<code>return false</code> 不仅阻止了事件往上冒泡，而且阻止了事件本身(默认事件)。<code>event.stopPropagation()</code>则只阻止事件往上冒泡，不阻止事件本身。</p>
<ul>
<li>event.target==event.currentTarget，让触发事件的元素等于绑定事件的元素，也可以阻止事件冒泡；</li>
</ul>
</li>
<li><p>阻止默认事件</p>
<ul>
<li>event.preventDefault( ) ——非 IE 使用</li>
<li>e.returnValue = false    IE 使用</li>
<li>return false    通用的，但是用的时候要小心</li>
</ul>
</li>
</ul>
<h3 id="防抖与节流"><a href="#防抖与节流" class="headerlink" title="防抖与节流"></a>防抖与节流</h3><ul>
<li><strong>debounce（防抖）</strong></li>
</ul>
<p>触发高频时间后n秒内函数只会执行一次,如果n秒内高频时间再次触发,则重新计算时间。</p>
<p><strong>实现方式：</strong> 周期内有新事件触发时，重置定时器开始时间撮，定时器执行时，判断开始时间撮，若开始时间撮被推后，重新设定延时定时器，否则立即执行并清除定时器。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个是用来获取当前时间戳的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">now</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> +<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 防抖函数，返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;function&#125;</span> </span>func        回调函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;number&#125;</span>   </span>wait        表示时间窗口的间隔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;boolean&#125;</span>  </span>immediate   设置为ture时，是否立即调用函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;function&#125;</span>             </span>返回客户调用函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span> (<span class="params">func, wait = <span class="number">50</span>, immediate = <span class="literal">true</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer, context, args</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 延迟执行函数</span></span><br><span class="line">  <span class="keyword">const</span> later = <span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 延迟函数执行完毕，清空缓存的定时器序号</span></span><br><span class="line">    timer = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 延迟执行的情况下，函数会在延迟函数中执行</span></span><br><span class="line">    <span class="comment">// 使用到之前缓存的参数和上下文</span></span><br><span class="line">    <span class="keyword">if</span> (!immediate) &#123;</span><br><span class="line">      func.apply(context, args)</span><br><span class="line">      context = args = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, wait)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里返回的函数是每次实际调用的函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...params</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果没有创建延迟执行函数（later），就创建一个</span></span><br><span class="line">    <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">      timer = later()</span><br><span class="line">      <span class="comment">// 如果是立即执行，调用函数</span></span><br><span class="line">      <span class="comment">// 否则缓存参数和调用上下文</span></span><br><span class="line">      <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">        func.apply(<span class="built_in">this</span>, params)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        context = <span class="built_in">this</span></span><br><span class="line">        args = params</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// 如果已有延迟执行函数（later），调用的时候清除原来的并重新设定一个</span></span><br><span class="line">    <span class="comment">// 这样做延迟函数会重新计时</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">      timer = later()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">原文链接：https:<span class="comment">//blog.csdn.net/qq_29557739/article/details/96430431</span></span><br></pre></td></tr></table></figure>

<p>防抖常应用于用户进行搜索输入节约请求资源，window触发resize事件时进行防抖只触发一次。</p>
<ul>
<li><strong>throttle（节流）</strong></li>
</ul>
<p>高频时间触发,但n秒内只会执行一次,所以节流会稀释函数的执行频率。</p>
<p><strong>实现方式：</strong>每次触发事件时，如果当前有等待执行的延时函数，则直接return</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">let</span> canRun = <span class="literal">true</span>; <span class="comment">// 通过闭包保存一个标记</span></span><br><span class="line">     <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!canRun) <span class="keyword">return</span>; <span class="comment">// 在函数开头判断标记是否为 true，不为 true 则 return</span></span><br><span class="line">       canRun = <span class="literal">false</span>; <span class="comment">// 立即设置为 false</span></span><br><span class="line">       <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 将外部传入的函数的执行放在 setTimeout 中</span></span><br><span class="line">         fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">         <span class="comment">// 最后在 setTimeout 执行完毕后再把标记设置为 true(关键) </span></span><br><span class="line">         <span class="comment">//表示可以执行下一次循环了。当定时器没有执行的时候</span></span><br><span class="line">         <span class="comment">//标记永远是 false，在开头被 return 掉</span></span><br><span class="line">         canRun = <span class="literal">true</span>;</span><br><span class="line">       &#125;, <span class="number">500</span>);</span><br><span class="line">     &#125;;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(e.target.innerWidth, e.target.innerHeight);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;resize&#x27;</span>, throttle(sayHi));</span><br><span class="line">原文链接：https:<span class="comment">//blog.csdn.net/qq_29557739/article/details/96430431</span></span><br></pre></td></tr></table></figure>

<p>节流常应用于鼠标不断点击触发、监听滚动事件。</p>
<ul>
<li><strong>区别：防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行。</strong></li>
</ul>
<h3 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h3><ul>
<li><strong>概念：</strong>是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。</li>
<li><strong>流程：</strong><ul>
<li>客户端使用用户名跟密码请求登录</li>
<li>服务端收到请求，去验证用户名与密码</li>
<li>验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端</li>
<li>客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里</li>
<li>客户端每次向服务端请求资源的时候需要带着服务端签发的 Token</li>
<li>服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据</li>
<li>APP登录的时候发送加密的用户名和密码到服务器，服务器验证用户名和密码，如果成功，以某种方式比如随机生成32位的字符串作为token，存储到服务器中，并返回token到APP，以后APP请求时，</li>
<li>凡是需要验证的地方都要带上该token，然后服务器端验证token，成功返回所需要的结果，失败返回错误信息，让他重新登录。其中服务器上token设置一个有效期，每次APP请求的时候都验证token和有效期。</li>
</ul>
</li>
</ul>
<h3 id="Session、Cookie、Token区别"><a href="#Session、Cookie、Token区别" class="headerlink" title="Session、Cookie、Token区别"></a>Session、Cookie、Token区别</h3><ul>
<li>概念<ul>
<li>session<ul>
<li>当用户打开某个web应用时，便与web服务器产生一次session。服务器使用session把用户的信息临时保存在了服务器上，用户离开网站后session会被销毁。</li>
</ul>
</li>
<li>cookie<ul>
<li> cookie是保存在本地终端的数据。cookie由服务器生成，发送给浏览器，浏览器把cookie以kv形式保存到某个目录下的文本文件内，下一次请求同一网站时会把该cookie发送给服务器。</li>
</ul>
</li>
<li>token<ul>
<li> token的意思是“令牌”，是用户身份的验证方式</li>
</ul>
</li>
</ul>
</li>
<li>cookie和session的区别<ul>
<li>1、cookie数据存放在客户的浏览器上，session数据放在服务器上。</li>
<li>2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session。</li>
<li>3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用COOKIE。</li>
<li>4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</li>
</ul>
</li>
<li>token和session的区别<ul>
<li>1、作为身份认证 token安全性比session好，因为每个请求都有签名还能防止监听以及重放攻击，而session就必须靠链路层来保障通讯安全。</li>
<li>2、如果你的用户数据可能需要和第三方共享，或者允许第三方调用 API 接口，用 Token </li>
<li>3、Session的状态是存储在服务器端，客户端只有session id；而Token的状态是存储在客户端。</li>
</ul>
</li>
</ul>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>​        当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的<code>_proto_</code>隐式原型上查找，即它的构造函数的<code>prototype</code>，如果还没有找到就会再在构造函数的<code>prototype</code>的<code>_proto_</code>_中查找，这样一层一层向上查找就会形成—个链式结构，我们称为<code>原型链</code>。</p>
<h3 id="高并发如何处理"><a href="#高并发如何处理" class="headerlink" title="高并发如何处理"></a>高并发如何处理</h3><ol>
<li>利用缓存，精简请求</li>
<li>合并压缩</li>
<li>静态资源上传cdn</li>
<li>避免高频刷新页面获取数据</li>
<li>设置响应头cache-control和last-modified</li>
</ol>
<h3 id="和-、-和-、-和-、-amp-amp-和-amp-与-和"><a href="#和-、-和-、-和-、-amp-amp-和-amp-与-和" class="headerlink" title="??和?.、!和!!、==和===、&amp;&amp;和&amp;与||和|"></a>??和?.、!和!!、==和===、&amp;&amp;和&amp;与||和|</h3><ul>
<li><p>??和?.</p>
<ul>
<li><strong>空值合并</strong>操作符（<code>??</code>）<ul>
<li>空值合并操作符（<code>??</code>）是一个逻辑操作符，当左侧的操作数为 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null"><code>null</code></a> 或者 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined"><code>undefined</code></a> 时，返回其右侧操作数，否则返回左侧操作数。</li>
</ul>
</li>
<li><strong>可选链</strong>操作符( <code>?.</code> )<ul>
<li>可选链操作符( <strong>?.</strong> )允许读取位于连接对象链深处的属性的值，而不必明确验证链中的每个引用是否有效。<code>?.</code> 操作符的功能类似于 <code>.</code> 链式操作符，不同之处在于，在引用为空(<a target="_blank" rel="noopener" href="https://wiki.developer.mozilla.org/en-US/docs/Glossary/nullish">nullish</a> ) (<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null"><code>null</code></a> 或者 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined"><code>undefined</code></a>) 的情况下不会引起错误，该表达式短路返回值。</li>
</ul>
</li>
</ul>
</li>
<li><p>!和!!</p>
<ul>
<li><code>!</code>是逻辑取反，非的意思,可以与任何变量进行逻辑与将其转化为布尔值</li>
<li><code>!!</code>常常用来做类型判断，在第一步!（变量）之后再做逻辑取反运算<ul>
<li>判断变量为非空，未定义或者非空串才能执行方法体的内容</li>
</ul>
</li>
</ul>
</li>
<li><p>=和==和===</p>
<p><strong>一个等号是赋值操作，==先转换类型再比较，===先判断类型，如果不是同一类型直接为false。</strong></p>
<ul>
<li><code>==</code>判断相等的程度较浅，只判断数值而不判断数据类型，换言之 ，用<code>==</code>作比较的时候可以自动为我们转换数据的类型；</li>
<li><code>===</code>判断相等的程度比<code>==</code>深，及判断数值，也判断数据类型，不可以自动转换数据的类型。</li>
</ul>
</li>
<li><p>&amp;&amp;和&amp;与||和|</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_30810583/article/details/99949923">https://blog.csdn.net/weixin_30810583/article/details/99949923</a></p>
<ul>
<li>“&amp;”<ul>
<li>运算方法：<ul>
<li>两个数值的个位分别相与，同时为1才得1，只要一个为0就为0。</li>
</ul>
</li>
</ul>
</li>
<li>“|”<ul>
<li>运算方法：<ul>
<li>两个位只要有一个为1，那么结果都为1。否则就为0。</li>
</ul>
</li>
</ul>
</li>
<li>“&amp;&amp;”<ul>
<li>运算方法：<ul>
<li>只要“&amp;&amp;”前面是false，无论“&amp;&amp;”后面是true还是false，结果都将返“&amp;&amp;”前面的值；</li>
<li>只要“&amp;&amp;”前面是true，无论“&amp;&amp;”后面是true还是false，结果都将返“&amp;&amp;”后面的值；</li>
</ul>
</li>
</ul>
</li>
<li>“||”<ul>
<li>运算方法：<ul>
<li>只要“||”前面为false，不管“||”后面是true还是false，都返回“||”后面的值。</li>
<li>只要“||”前面为true，不管“||”后面是true还是false，都返回“||”前面的值。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="HTTP请求的常用方法有哪些"><a href="#HTTP请求的常用方法有哪些" class="headerlink" title="HTTP请求的常用方法有哪些"></a>HTTP请求的常用方法有哪些</h3><p><strong>1、GET方法</strong></p>
<p>GET方法用于使用给定的URL从给定服务器中检索信息，即从指定资源中请求数据。使用GET方法的请求应该只是检索数据，并且不应对数据产生其他影响。</p>
<p>说明：</p>
<p>GET请求是可以缓存的，我们可以从浏览器历史记录中查找到GET请求，还可以把它收藏到书签中；且GET请求有长度限制，仅用于请求数据（不修改）。</p>
<p>注：因GET请求的不安全性，在处理敏感数据时，绝不可以使用GET请求。</p>
<p><strong>2、POST方法</strong></p>
<p>POST方法用于将数据发送到服务器以创建或更新资源，它要求服务器确认请求中包含的内容作为由URI区分的Web资源的另一个下属。</p>
<p>POST请求永远不会被缓存，且对数据长度没有限制；我们无法从浏览器历史记录中查找到POST请求。</p>
<p><strong>3、HEAD方法</strong></p>
<p>HEAD方法与GET方法相同，但没有响应体，仅传输状态行和标题部分。这对于恢复相应头部编写的元数据非常有用，而无需传输整个内容。</p>
<p><strong>4、PUT方法</strong></p>
<p>PUT方法用于将数据发送到服务器以创建或更新资源，它可以用上传的内容替换目标资源中的所有当前内容。</p>
<p>它会将包含的元素放在所提供的URL下，如果URL指示的是当前资源，则会被改变。如果URL未指示当前资源，则服务器可以使用该URI创建资源。</p>
<p><strong>5、DELETE方法</strong></p>
<p>DELETE方法用来删除指定的资源，它会删除URI给出的目标资源的所有当前内容。</p>
<p><strong>6、CONNECT方法</strong></p>
<p>CONNECT方法用来建立到给定URI标识的服务器的隧道；它通过简单的TCP / IP隧道更改请求连接，通常实使用解码的HTTP代理来进行SSL编码的通信（HTTPS）。</p>
<p><strong>7、OPTIONS方法</strong></p>
<p>OPTIONS方法用来描述了目标资源的通信选项，会返回服务器支持预定义URL的HTTP策略。</p>
<p><strong>8、TRACE方法</strong></p>
<p>TRACE方法用于沿着目标资源的路径执行消息环回测试；它回应收到的请求，以便客户可以看到中间服务器进行了哪些（假设任何）进度或增量。</p>
<h3 id="GET和POST两种基本请求方法的区别"><a href="#GET和POST两种基本请求方法的区别" class="headerlink" title="GET和POST两种基本请求方法的区别"></a>GET和POST两种基本请求方法的区别</h3><p>包括底层也解释到了<a target="_blank" rel="noopener" href="https://www.cnblogs.com/logsharing/p/8448446.html">https://www.cnblogs.com/logsharing/p/8448446.html</a></p>
<ol>
<li><p>get是从服务器上获取数据，post是向服务器传送数据。</p>
</li>
<li><p>get是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到。post是通过HTTPpost机制，将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址。用户看不到这个过程。</p>
</li>
<li><p>对于get方式，服务器端用Request.QueryString获取变量的值，对于post方式，服务器端用Request.Form获取提交的数据。</p>
</li>
<li><p>get传送的数据量较小，不能大于2KB。post传送的数据量较大，一般被默认为不受限制。但理论上，IIS4中最大量为80KB，IIS5中为100KB。（这里有看到其他文章介绍get和post的传送数据大小跟各个浏览器、操作系统以及服务器的限制有关）</p>
</li>
<li><p>get安全性非常低，post安全性较高。</p>
</li>
</ol>
<h1 id="三、react"><a href="#三、react" class="headerlink" title="三、react"></a>三、react</h1><h3 id="react的生命周期"><a href="#react的生命周期" class="headerlink" title="react的生命周期"></a>react的生命周期</h3><ul>
<li>旧版本的生命周期<ul>
<li>初始化阶段：<ul>
<li>constructor()</li>
<li>componentWillMount()</li>
<li>render()</li>
<li>componentDidMount() 1</li>
</ul>
</li>
<li>更新阶段：<ul>
<li>componentWillReceiveProps()</li>
<li>shouldComponentUpdate()</li>
<li>componentWillUpdate()</li>
<li>render()</li>
<li>componentDidUpdate() 1</li>
</ul>
</li>
<li>销毁阶段：<ul>
<li>componentWillUnmount()</li>
</ul>
</li>
</ul>
</li>
<li>新版本的生命周期<ul>
<li>初始化阶段：<ul>
<li>constructor()</li>
<li>getDerivedStateFromProps</li>
<li>render()</li>
<li>componentDidMount()</li>
</ul>
</li>
<li>更新阶段：<ul>
<li>getDerivedStateFromProps</li>
<li>shouldComponentUpdata()</li>
<li>render()</li>
<li>getSnapshotBeforeUpdate</li>
<li>componentDidUpdate()</li>
</ul>
</li>
<li>卸载阶段：<ul>
<li>comoonentWillUnmount()</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="react中何时渲染页面"><a href="#react中何时渲染页面" class="headerlink" title="react中何时渲染页面"></a>react中何时渲染页面</h3><ul>
<li>class 组件的 constructor 方法</li>
<li>render 方法</li>
<li>setState 更新函数 (第一个参数）</li>
<li>静态的 getDerivedStateFromProps 生命周期方法</li>
</ul>
<h3 id="关于-react中setState是同步的还是异步"><a href="#关于-react中setState是同步的还是异步" class="headerlink" title="关于 react中setState是同步的还是异步"></a>关于 react中<code>setState</code>是同步的还是异步</h3><p><strong>state是具有更新队列的，每次调用setState方法都会将当前修改的state放入此队列，react查询到当前setState方法执行完后，进行state数据的合并，合并后再去执行回调，根据合并结果再去执行更新VirtualDom，触发render周期</strong></p>
<ul>
<li><strong>a：</strong><code>setState</code> 只在合成事件和hook（）中是“异步”的，在<strong>原生事件和 setTimeout</strong> 中都是<strong>同步</strong>的。</li>
<li><strong>b：</strong> <code>setState</code>的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是<strong>合成事件和hook（）的调用顺序在更新之前</strong>，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，当然可以通过第二个参数 setState(partialState, <strong>callback</strong>) 拿到更新后的结果。</li>
<li><strong>c：</strong> <code>setState</code> 的批量更新优化也是建立在“异步”（合成事件、hook（））之上的，<strong>在原生事件和setTimeout 中不会批量更新</strong>，在“异步”中如果对同一个值进行多次 <code>setState</code> ， <code>setState</code> 的批量更新策略会对其进行覆盖，取<strong>最后一次的执行</strong>，如果是同时 <code>setState</code> 多个不同的值，在更新时会<strong>对其进行合并批量更新</strong>。</li>
</ul>
<h3 id="react中如何获取input输入框的值"><a href="#react中如何获取input输入框的值" class="headerlink" title="react中如何获取input输入框的值"></a>react中如何获取input输入框的值</h3><p>以下为在类组件中方法</p>
<ul>
<li>受控组件的获取，this.setState</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//input 输入框的值会随着用户输入的改变而改变，onChange通过对象e拿到改变之后的状态并更新state，setState根据新的状态触发视图渲染，完成更新。</span></span><br><span class="line">&lt;input onChange=&#123;<span class="function">(<span class="params">e</span>)=&gt;</span><span class="built_in">this</span>.inputChange(e)&#125;/&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>this.getInputValue&#125; &gt;获取input的值<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">inputChange</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">	alert(e.target.value)</span><br><span class="line">	<span class="built_in">this</span>.setState(&#123;</span><br><span class="line">		<span class="attr">username</span>:e.target.value</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">getInputValue</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="built_in">this</span>.state.username)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>非受控组件的获取，ref</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用defaultValue表示组件的默认状态，此时它只会被渲染一次，后续的渲染不起作用；input的值不随外部的改变而改变，由自己状态改变。</span></span><br><span class="line"><span class="keyword">import</span> React , &#123;Component&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="title">search</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">const</span> inpVal = <span class="built_in">this</span>.input.value;</span><br><span class="line">		<span class="built_in">console</span>.log(inpVal);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span>(</span><br><span class="line">			<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">				<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;input</span> =&gt;</span> this.input = input&#125;</span></span><br><span class="line"><span class="xml">                    defaultValue=&quot;Hello&quot;/&gt;</span></span><br><span class="line"><span class="xml">				<span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.search.bind(this)&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h3 id="在使用react时使用到redux"><a href="#在使用react时使用到redux" class="headerlink" title="在使用react时使用到redux"></a>在使用react时使用到redux</h3><p>关于redux</p>
<p>action</p>
<ul>
<li><ol>
<li>动作的对象</li>
</ol>
</li>
<li><ol start="2">
<li>包含2个属性</li>
</ol>
<ul>
<li>type：标识属性, 值为字符串, 唯一, 必要属性</li>
<li>data：数据属性, 值类型任意, 可选属性</li>
</ul>
</li>
<li><ol start="3">
<li>例子：{ type: ‘ADD_STUDENT’,data:{name: ‘tom’,age:18} }</li>
</ol>
</li>
</ul>
<p>reducer</p>
<ul>
<li><ol>
<li>用于初始化状态、加工状态。</li>
</ol>
</li>
<li><ol start="2">
<li>加工时，根据旧的state和action， 产生新的state的<strong>纯函数</strong>。</li>
</ol>
</li>
</ul>
<p>store</p>
<ul>
<li><ol>
<li>将state、action、reducer联系在一起的对象</li>
</ol>
</li>
<li><ol start="2">
<li>如何得到此对象?</li>
</ol>
<ul>
<li>1)import {createStore} from ‘redux’</li>
<li>2)import reducer from ‘./reducers’</li>
<li>3)const store = createStore(reducer)</li>
</ul>
</li>
<li><ol start="3">
<li>此对象的功能?</li>
</ol>
<ul>
<li>1)getState(): 得到state</li>
<li>2)dispatch(action): 分发action, 触发reducer调用, 产生新的state</li>
<li>3)subscribe(listener): 注册监听, 当产生了新的state时, 自动调用</li>
</ul>
</li>
</ul>
<p>什么情况下使用redux</p>
<ul>
<li>某个组件的状态，需要让其他组件可以随时拿到（共享）。</li>
<li>一个组件需要改变另一个组件的状态（通信）。</li>
</ul>
<h3 id="高阶函数-amp-函数的柯里化-amp-高阶组件"><a href="#高阶函数-amp-函数的柯里化-amp-高阶组件" class="headerlink" title="高阶函数&amp;函数的柯里化&amp;高阶组件"></a>高阶函数&amp;函数的柯里化&amp;高阶组件</h3><ol>
<li>高阶函数：如果一个函数符合下面的两个规范中的任何一个，那该函数就是高阶函数。</li>
</ol>
<ul>
<li>1.若A函数，接受的参数是一个函数，那么A就可以称之为高阶函数。</li>
<li>2.若A函数，调用的返回值依然是一个函数，那么A就可以称之为高阶函数</li>
<li>常见的高阶函数有：<ul>
<li>a. Promise：Promise(() =&gt; {})  then(value =&gt; {}, reason =&gt; {})</li>
<li>b. 定时器：setTimeout() / setInterval()</li>
<li>c. 数组遍历相关的方法：forEach()/filter()/map()/reduce()/find()/findIndex()</li>
<li>d. 函数对象的bind()</li>
</ul>
</li>
</ul>
<ol start="2">
<li>函数的柯里化:通过函数调用继续返回函数的方式，实现多次接收参数最后统一处理的函数编码形式。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span><span class="function">(<span class="params">b</span>)=&gt;</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="function">(<span class="params">c</span>)=&gt;</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> a+b+c</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>高阶组件<ul>
<li>本质就是一个函数</li>
<li>接收一个组件(被包装组件)，返回一个新的组件(包装组件)，包装组件会向被包装组件传入特定属性</li>
<li>作用：扩展组件的功能</li>
<li>高阶组件也是高阶函数：接受一个组件函数，返回的是一个新的组件函数</li>
</ul>
</li>
</ol>
<h3 id="React性能优化"><a href="#React性能优化" class="headerlink" title="React性能优化"></a>React性能优化</h3><ul>
<li><p>适当地使用<code>shouldComponentUpdate</code>生命周期方法。 它避免了子组件的不必要的渲染。 如果树中有100个组件，则不重新渲染整个组件树来提高应用程序性能。</p>
</li>
<li><p>使用<code>create-react-app</code>来构建项目，这会创建整个项目结构，并进行大量优化。</p>
</li>
<li><p>不可变性是提高性能的关键。不要对数据进行修改，而是始终在现有集合的基础上创建新的集合，以保持尽可能少的复制，从而提高性能。</p>
</li>
<li><p>在显示列表或表格时始终使用 <code>Keys</code>，这会让 React 的更新速度更快</p>
</li>
<li><p>代码分离是将代码插入到单独的文件中，只加载模块或部分所需的文件的技术。</p>
</li>
</ul>
<h3 id="关于key的经典面试题"><a href="#关于key的经典面试题" class="headerlink" title="关于key的经典面试题"></a>关于key的经典面试题</h3><h4 id="（1）react-vue中的key有什么作用？（key的内部原理是什么？）"><a href="#（1）react-vue中的key有什么作用？（key的内部原理是什么？）" class="headerlink" title="（1）react/vue中的key有什么作用？（key的内部原理是什么？）"></a>（1）react/vue中的key有什么作用？（key的内部原理是什么？）</h4><h4 id="（2）为什么遍历列表时，key最好不要用index？"><a href="#（2）为什么遍历列表时，key最好不要用index？" class="headerlink" title="（2）为什么遍历列表时，key最好不要用index？"></a>（2）为什么遍历列表时，key最好不要用index？</h4><ul>
<li>1、虚拟DOM中key的作用： <ul>
<li>1.简单来说：key是虚拟DOM对象的标识，在更新显示时key起着极其重要的作用。</li>
<li>2.详细的说：当状态 中的数据发生改变时，react会根据【新数据】生成【新的修DOM】，随后React进行【新虚拟DOM】与【旧虚拟DOM】的diffing比较，比较规则如下：<ul>
<li>A、旧虚拟DOM中找到了与新虚拟DOM相同的key：<ul>
<li>a、若虚拟DOM中内容没变，直接使用之前的真实DOM</li>
<li>b、若虚拟DOM中内容变了，则生成新的真是DOM，随后替换掉页面中之前的真实DOM</li>
</ul>
</li>
<li>B、旧虚拟DOM中未找到与新虚拟DOM相同的key<ul>
<li>根据数据创建新的真实虚拟DOM</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>2、用index作为key可能会引发的问题：<ul>
<li>1.若对数据进行：逆序添加、逆序删除等破坏顺序操作：<ul>
<li>会产生没有必要的真实DOM更新 ==&gt; 界面效果没有问题，但效率低下</li>
</ul>
</li>
<li>2.若结构中还包含输入类的DOM：<ul>
<li>会产生错误DOM更新 ==&gt; 界面有问题</li>
</ul>
</li>
<li>3.注意！如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅仅用于渲染列表、用于展示，使用index作为key时没有问题的。</li>
</ul>
</li>
</ul>
<h3 id="组件通信方式总结"><a href="#组件通信方式总结" class="headerlink" title="组件通信方式总结"></a>组件通信方式总结</h3><ul>
<li><p>组件间的关系：</p>
<ul>
<li>父子组件</li>
<li>兄弟组件（非嵌套组件）</li>
<li>祖孙组件（跨级组件）</li>
</ul>
</li>
<li><p>几种通信方式：</p>
<ul>
<li>1.props：<ul>
<li>(1).children props</li>
<li>(2).render props</li>
</ul>
</li>
<li>2.消息订阅-发布：<ul>
<li><strong>pubs-sub</strong>、event等等</li>
</ul>
</li>
<li>3.集中式管理：<ul>
<li><strong>redux</strong>、dva等等</li>
</ul>
</li>
<li>4.conText:<ul>
<li>生产者-消费者模式</li>
</ul>
</li>
</ul>
</li>
<li><p>比较好的搭配方式：</p>
<ul>
<li>父子组件：props<ul>
<li>父给子传数据：直接使用props</li>
<li><strong>子给父</strong>传数据：有一个前提是需要父组件给子组件先传一个函数，子组件在合适的时候去调用父组件传下来的函数，就能实现子组件给父组件传数据。</li>
</ul>
</li>
<li>兄弟组件：消息订阅-发布、集中式管理</li>
<li>祖孙组件(跨级组件)：消息订阅-发布、集中式管理、conText(开发用的少，封装插件用的多)</li>
</ul>
</li>
</ul>
<h3 id="React中的Context"><a href="#React中的Context" class="headerlink" title="React中的Context"></a>React中的Context</h3><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000017758300">https://segmentfault.com/a/1190000017758300</a></p>
<ul>
<li><p>react父子组件的通信——通过props进行数据的传递</p>
<ul>
<li>1、父组件向子组件传递数据(状态)时，是在调用子组件的时候通过参数传递给子组件，子组件通过this.props进行接收；</li>
<li>2、子组件如果更改父组件的一些属性，则是通过父组件定义的方法来传递给子组件，子组件调用更改；</li>
<li>3、如果父组件想要更改子组件的一些状态时，通过ref进行标记，可以获取子组件的所有信息，从而调用子组件的方法和值；</li>
</ul>
<p>但是，如果层级很多，我们仍使用props来传递就会需要逐层的传递，很麻烦且容易混乱，但是React的advanced(高级)中指出了context，优雅的解决这个问题。</p>
</li>
<li><p>Context</p>
<ul>
<li>在js中：context指的是函数的执行上下文，函数被调用时，this指向谁，谁就是当前的执行上下文；</li>
<li>在react中：如果我们不想通过props实现组件树的逐层传递数据，则可以使用context实现跨层级进行数据传递；</li>
<li>在React-redux中：通过Provider组件和connect方法进行连接react和redux,那么他们到底本质上就是通过Context来传递数据</li>
</ul>
</li>
<li><p>如何使用Context</p>
<p>context api给出三个概念：React.createContext()、Provider、Consumer；</p>
<ul>
<li>React.createContext()</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个方法用来创建context对象，并包含Provider、Consumer两个组件 &lt;Provider /&gt;、&lt;Consumer /&gt;</span></span><br><span class="line"><span class="keyword">const</span> &#123;Provider, Consumer&#125; = React.createContext();</span><br></pre></td></tr></table></figure>

<ul>
<li>Provider</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据的生产者，通过value属性接收存储的公共状态，来传递给子组件或后代组件eg:</span></span><br><span class="line">&lt;Provider value=&#123;<span class="comment">/* some value */</span>&#125;&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>Consumer</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据的消费者，通过订阅Provider传入的context的值，来实时更新当前组件的状态eg: </span></span><br><span class="line">&lt;Consumer&gt;</span><br><span class="line">  &#123;<span class="function"><span class="params">value</span> =&gt;</span> <span class="comment">/* render something based on the context value */</span>&#125;</span><br><span class="line">&lt;/Consumer&gt;</span><br></pre></td></tr></table></figure>

<p><strong>值得一提的是每当Provider的值发生改变时, 作为Provider后代的所有Consumers都会重新渲染</strong></p>
</li>
</ul>
<h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h3><ul>
<li><p>前情提要</p>
<ul>
<li>只进行单纯的数据计算（换算）的函数，在函数式编程里面称为 **”纯函数”**（pure function）。</li>
<li>函数式编程将那些跟数据计算无关的操作（比如生成日志、储存数据、改变应用状态等等），都称为 “副效应” <strong>（side effect）</strong> 。</li>
<li><strong>钩子（hook）就是 React 函数组件的副效应解决方案，用来为函数组件引入副效应。</strong></li>
<li><strong>useEffect()是通用的副效应钩子</strong> 。找不到对应的钩子时，就可以用它。</li>
</ul>
</li>
<li><p>使用</p>
<ul>
<li><code>useEffect()</code>的作用就是指定一个副效应函数，组件每渲染一次，该函数就自动执行一次。组件首次在网页 DOM 加载后，副效应函数也会执行。</li>
<li>用法<ul>
<li>第一个参数是一个函数，它就是所要完成的副效应（改变网页标题）。组件加载以后，React 就会执行这个函数。</li>
<li>第二个参数是一个数组，指定了第一个参数（副效应函数）的依赖项（<code>props.name</code>）。只有该变量发生变化时，副效应函数才会执行。<ul>
<li>如果第二个参数是一个空数组，就表明副效应参数没有任何依赖项。组件加载进入 DOM 后执行一次，后面组件重新渲染，就不会再次执行。</li>
</ul>
</li>
</ul>
</li>
<li>用途<ul>
<li>获取数据（data fetching）</li>
<li>事件监听或订阅（setting up a subscription）</li>
<li>改变 DOM（changing the DOM）</li>
<li>输出日志（logging）</li>
</ul>
</li>
<li>返回值<ul>
<li>允许返回一个函数，在组件卸载时，执行该函数，清理副效应。如果不需要清理副效应，<code>useEffect()</code>就不用返回任何值。</li>
</ul>
</li>
<li>注意点<ul>
<li>如果有多个副效应，应该调用多个<code>useEffect()</code>，而不应该合并写在一起。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="react-事件绑定的原理"><a href="#react-事件绑定的原理" class="headerlink" title="react 事件绑定的原理"></a>react 事件绑定的原理</h3><p>react中的事件都是合成事件，不是把每一个dom的事件绑定在dom上，而是把事件统一绑定到document中，触发时通过事件冒泡到document进行触发合成事件，因为是合成事件，所以我们无法去使用e.stopPropagation去阻止，而是使用e.preventDefault去阻止。</p>
<ul>
<li><p>1.<strong>事件注册</strong>：组件更新或者装载时，在给dom增加合成事件时，需要将增加的target传入到document进行判断，给document注册原生事件回调为dispatchEvent(统一的事件分发机制)。</p>
</li>
<li><p>2.<strong>事件存储</strong>：EventPluginHub负责管理React合成事件的callback,它将callback存储到listennerBank中，另外还存储了负责合成事件的Plugin，Event存储到listennerbank中，每一个元素在listennerBank中会有唯一的key。</p>
</li>
<li><p>3.<strong>事件触发执行</strong>：点击时冒泡到docunment中，触发注册原生事件的回调dispatchEvent，获取到触发这个事件的最深层元素，事件执行利用react的批处理机制。<br> 案例</p>
</li>
<li><p>4.<strong>合成事件</strong>：循环所有类型的eventPlugin，对应每个事件类型，生成不同的事件池，如果是空，则生成新的，有则用之前的，根据唯一key获取到指定的回调函数，再返回带有参数的回调函数。</p>
</li>
</ul>
<h3 id="受控组件与非受控组件"><a href="#受控组件与非受控组件" class="headerlink" title="受控组件与非受控组件"></a>受控组件与非受控组件</h3><ul>
<li>受控组件<ul>
<li>1、每当表单的状态发生变化时，都会被写入到组件的state中</li>
<li>2、在受控组件中，组件渲染出的状态与它的value或checked prop相对应</li>
<li>3、react受控组件更新state的流程</li>
</ul>
</li>
<li>非受控组件<ul>
<li>1、如果一个表单组件没有value prop就可以称为非受控组件</li>
<li>2、非受控组件是一种反模式，它的值不受组件自身的state或props控制</li>
<li>3、通常需要为其添加ref prop来访问渲染后的底层DOM元素</li>
</ul>
</li>
</ul>
<h3 id="setstate在哪些生命周期可以无副作用使用"><a href="#setstate在哪些生命周期可以无副作用使用" class="headerlink" title="setstate在哪些生命周期可以无副作用使用"></a>setstate在哪些生命周期可以无副作用使用</h3><ul>
<li><p>componentDidMount()</p>
</li>
<li><p>可以在<code>UNSAFE_componentWillReceiveProps</code>周期获取最新的props在通过setState更新组件状态。</p>
</li>
<li><p>在<code>componentDidUpdate</code>生命周期中setState会导致视图再次更新</p>
<ul>
<li>除非特殊业务需求，否则不建议在此生命周期中使用setState。</li>
</ul>
</li>
</ul>
<h3 id="props或state发生变化会触发哪些生命周期"><a href="#props或state发生变化会触发哪些生命周期" class="headerlink" title="props或state发生变化会触发哪些生命周期"></a>props或state发生变化会触发哪些生命周期</h3><ul>
<li><p>UNSAFE_componentWillReceiveProps()</p>
</li>
<li><p>shouldComponentUpdate()</p>
<ul>
<li>它通过判断当前状态与之前状态来返回一个布尔值并决定是否更新视图，如果返回false视图始终不会更新。返回true就会更新视图</li>
</ul>
</li>
<li><p>UNSAFE_componentWillUpdate()</p>
</li>
<li><p>render()</p>
</li>
<li><p>componentDidUpdate()</p>
</li>
</ul>
<h3 id="react-thunk——中间件"><a href="#react-thunk——中间件" class="headerlink" title="react-thunk——中间件"></a>react-thunk——中间件</h3><p><code>redux-thunk</code>是作为<code>redux</code>的 middleware 存在的，用法和普通 middleware 的用法是一样的，注册 middleware 的代码如下：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> thunkMiddleware <span class="keyword">from</span> <span class="string">&#x27;redux-thunk&#x27;</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer, applyMiddleware(thunkMiddleware))</span><br></pre></td></tr></table></figure>

<p>注册后可以这样使用：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于发起登录请求，并处理请求结果</span></span><br><span class="line"><span class="comment">// 接受参数用户名，并返回一个函数(参数为dispatch)</span></span><br><span class="line"><span class="keyword">const</span> login = <span class="function">(<span class="params">userName</span>) =&gt;</span> <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">  dispatch(&#123; <span class="attr">type</span>: <span class="string">&#x27;loginStart&#x27;</span> &#125;)</span><br><span class="line">  request.post(<span class="string">&#x27;/api/login&#x27;</span>, &#123; <span class="attr">data</span>: userName &#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    dispatch(&#123; <span class="attr">type</span>: <span class="string">&#x27;loginSuccess&#x27;</span>, <span class="attr">payload</span>: userName &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">store.dispatch(login(<span class="string">&#x27;Lucy&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>它的核心代码其实只有两行，就是判断每个经过它的<code>action</code>：如果是<code>function</code>类型，就调用这个<code>function</code>（并传入 dispatch 和 getState 及 extraArgument 为参数），而不是任由让它到达 reducer，因为 reducer 是个纯函数，Redux 规定到达 reducer 的 action 必须是一个 plain(朴实的) object 类型。</p>
<h3 id="一个react项目从拿到手到上线的全流程"><a href="#一个react项目从拿到手到上线的全流程" class="headerlink" title="一个react项目从拿到手到上线的全流程"></a>一个react项目从拿到手到上线的全流程</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/aloneindefeat/p/11162531.html">https://www.cnblogs.com/aloneindefeat/p/11162531.html</a></p>
<ul>
<li><ol>
<li>安装nodejs</li>
</ol>
</li>
<li><ol start="2">
<li>使用nodejs的npm包安装create-react-app模块</li>
</ol>
</li>
<li><ol start="3">
<li>使用creat-react-app模块创建我们的项目</li>
</ol>
</li>
<li><ol start="4">
<li>了解控制我们项目运行测试打包的几个命令</li>
</ol>
</li>
<li><ol start="5">
<li>通过npm start运行我们的项目</li>
</ol>
</li>
<li><ol start="6">
<li>查看生产的项目目录的结构，并了解其作用</li>
</ol>
</li>
<li><ol start="7">
<li>开始创建几个我们自己的组件</li>
</ol>
</li>
<li><ol start="8">
<li>再次运行我们的项目</li>
</ol>
</li>
<li><ol start="9">
<li>开始打包生产环境中需要的代码</li>
</ol>
</li>
<li><ol start="10">
<li>将我们的代码部署进入我们的服务器</li>
</ol>
</li>
<li><ol start="11">
<li>ok,上线了，我们可以让用户正式访问了</li>
</ol>
</li>
<li><ol start="12">
<li>维护调试</li>
</ol>
</li>
</ul>
<h3 id="什么是高阶组件（-HOC）"><a href="#什么是高阶组件（-HOC）" class="headerlink" title="什么是高阶组件（ HOC）"></a>什么是高阶组件（ HOC）</h3><p>高阶组件是重用组件的逻辑的高级方法</p>
<p>是一种源于React组件模式&lt;/pHOc是自定义组件,在他之内包含另一个</p>
<p>可以接受子组件提供的任何动态，但不会修改或复制其输入组件的任意行为HOC==“干净”组件</p>
<h1 id="其他技术"><a href="#其他技术" class="headerlink" title="其他技术"></a>其他技术</h1><h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><h4 id="git如何解决冲突"><a href="#git如何解决冲突" class="headerlink" title="git如何解决冲突"></a>git如何解决冲突</h4><ul>
<li><p>在 Git 的响应中,可以看到存在冲突</p>
</li>
<li><p>进入到merge-conflicts文件夹<code>cd merge-conflicts</code></p>
</li>
<li><p>找到<code>merge-conflicts/_data</code></p>
</li>
<li><p>可以看到存在冲突的文件，是以<code>.yml</code>结尾的文件，用文本编辑器打开它</p>
</li>
<li><p>查找以 开头<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code>、<code>============</code>结尾的标记大块 <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt; origin/main</code>。这三个标记是由 Git 添加的，用于显示冲突的内容。</p>
</li>
<li><p>通过删除<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code>下方 <code>=======</code>上方的内容或者是<code>=======</code>下方和<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt; origin/main</code>上方，的所有内容，来对主分支所做的更改。</p>
</li>
<li><p>保存修改，执行以下代码进行提交：</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;merge master into update-config&quot;</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure>



<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h4 id="TCP-IP体系结构"><a href="#TCP-IP体系结构" class="headerlink" title="TCP/IP体系结构"></a>TCP/IP体系结构</h4><p><img src="https://img-blog.csdn.net/20171215000304120?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjI0NjQ1NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/an-wen/p/11180076.html">https://www.cnblogs.com/an-wen/p/11180076.html</a></p>
<p>![img](file:///C:\Users\Administrator\Documents\Tencent Files\601539164\Image\Group2\0J\07\0J07]VA[1<del>P9TH32$BU`5</del>7.jpg)</p>
<p>promise练习题</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1627887951201.png" alt="1627887951201"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1627887982769.png" alt="1627887982769"></p>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://example.com/2021/08/05/%E8%87%AA%E5%B7%B1%E6%80%BB%E7%BB%93%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://example.com/2021/08/05/%E8%87%AA%E5%B7%B1%E6%80%BB%E7%BB%93%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a target="_blank" rel="noopener" href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
                <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
