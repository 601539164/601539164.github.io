<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/logo_miccall.png"/>
	<link rel="shortcut icon" href="/img/logo_miccall.png">
	
			    <title>
    阿诺撕码辛格
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="niuoke" />
    
    	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	 
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/bg.jpg') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<meta name="generator" content="Hexo 5.4.0"></head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_coy.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">NIUOKE</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/about/" title="简历">
		                简历
		            </a>
		        </li>
		        
		        <li>
		            <a href="/group/" title="团队">
		                团队
		            </a>
		        </li>
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="标签">
		                标签
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
                    <li>
                        <a title="github" href="https://github.com/miccall" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="500px" href="http://500px.com" target="_blank" rel="noopener">
                            <i class="icon fa fa-500px"></i>
                        </a>
                    </li>
                    
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(https://i.loli.net/2019/04/15/5cb48b98c423f.jpg);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >React 全家桶笔记</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <h1 id="第一章、react入门"><a href="#第一章、react入门" class="headerlink" title="第一章、react入门"></a>第一章、react入门</h1><h2 id="1、react简介"><a href="#1、react简介" class="headerlink" title="1、react简介"></a>1、react简介</h2><h3 id="1-1、react是什么？"><a href="#1-1、react是什么？" class="headerlink" title="1.1、react是什么？"></a>1.1、react是什么？</h3><ul>
<li><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1624256969113.png"></li>
</ul>
<h3 id="1-2、react的特点"><a href="#1-2、react的特点" class="headerlink" title="1.2、react的特点"></a>1.2、react的特点</h3><ul>
<li><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1624257859098.png" alt="1624257859098"></li>
</ul>
<h3 id="1-3、学习之前需掌握的javascript基础"><a href="#1-3、学习之前需掌握的javascript基础" class="headerlink" title="1.3、学习之前需掌握的javascript基础"></a>1.3、学习之前需掌握的javascript基础</h3><ul>
<li><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1624258362265.png" alt="1624258362265"></p>
</li>
<li><h4 id="this指向："><a href="#this指向：" class="headerlink" title="this指向："></a>this指向：</h4><ul>
<li>禁止自定义的函数，this指向window，所以这里this指的是undefined</li>
</ul>
</li>
<li><h4 id="class：实例、继承"><a href="#class：实例、继承" class="headerlink" title="class：实例、继承"></a>class：实例、继承</h4><ul>
<li>1.类中的构造器不是必须写的，要对实例进行一些初始化的操作，如添加指定执行时才写。</li>
<li>2.如果A类继承了B类，且A类中写了构造器，那么A类构造器中的super是必须要调用的。</li>
<li>3.类中所定义的方法，都是放在了类的原型对象上，供实例去使用</li>
<li>另外：对类的实例化对象进行一些初始化操作，如增加一个属性、修改一个属性，需要借助类的构造器</li>
</ul>
</li>
<li><h4 id="ES6：箭头函数、模板字符串、解构赋值"><a href="#ES6：箭头函数、模板字符串、解构赋值" class="headerlink" title="ES6：箭头函数、模板字符串、解构赋值"></a>ES6：箭头函数、模板字符串、解构赋值</h4></li>
<li><h4 id="npm包管理器：react脚手架"><a href="#npm包管理器：react脚手架" class="headerlink" title="npm包管理器：react脚手架"></a>npm包管理器：react脚手架</h4></li>
<li><h4 id="数组的常用方法：统计、遍历、过滤数组，条件筛选，条件求和，筛选最值等等"><a href="#数组的常用方法：统计、遍历、过滤数组，条件筛选，条件求和，筛选最值等等" class="headerlink" title="数组的常用方法：统计、遍历、过滤数组，条件筛选，条件求和，筛选最值等等"></a>数组的常用方法：统计、遍历、过滤数组，条件筛选，条件求和，筛选最值等等</h4></li>
</ul>
<h2 id="2、React的基本使用"><a href="#2、React的基本使用" class="headerlink" title="2、React的基本使用"></a>2、React的基本使用</h2><h3 id="2-1、关于虚拟DOM"><a href="#2-1、关于虚拟DOM" class="headerlink" title="2.1、关于虚拟DOM"></a>2.1、关于虚拟DOM</h3><ul>
<li>1.本质是Object类型的对象（一般对象）。</li>
<li>2.虚拟DOM比较“轻”，真是DOM比较“重”，因为虚拟DOM是React内部在用，无需真是DOM上那么多的属性。</li>
<li>3.虚拟DOM最终会被React转化成真是DOM，呈现在页面上。</li>
</ul>
<h3 id="2-2、jsx语法规则"><a href="#2-2、jsx语法规则" class="headerlink" title="2.2、jsx语法规则"></a>2.2、jsx语法规则</h3><ul>
<li><p>1.定义虚拟DOM，不要写引号。</p>
</li>
<li><p>2.标签中混入js表达式时要用{}包裹。</p>
</li>
<li><p>3.样式的类名指定不要用class，要用className。</p>
</li>
<li><p>4.需要书写内联样式时，要用style=的形式。</p>
</li>
<li><p>5.虚拟DOM只能有一个根标签。</p>
</li>
<li><p>6.标签必须闭合。</p>
</li>
<li><p>7.标签首字母</p>
<ul>
<li><p>（1）若小写字母开头，则将该标签转为html中同名元素，若html中无该标签对应的同名元素，则报错。</p>
</li>
<li><p>（2）若大写字母开头，react就去渲染对应的组件，若组件没有定义，则报错。</p>
<h4 id="注意：一定注意区分：【js语句-代码-】与【js表达式】"><a href="#注意：一定注意区分：【js语句-代码-】与【js表达式】" class="headerlink" title="注意：一定注意区分：【js语句(代码)】与【js表达式】"></a>注意：一定注意区分：【js语句(代码)】与【js表达式】</h4><p>​                    1.表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方。<br>​                                下面这些都是表达式：<br>​                                        (1). a<br>​                                        (2). a+b<br>​                                        (3). demo(1)<br>​                                        (4). arr.map()<br>​                                        (5). function test () {}<br>​                    2.语句(代码)：<br>​                                下面这些都是语句(代码)：<br>​                                        (1).if(){}<br>​                                        (2).for(){}<br>​                                        (3).switch(){case:xxxx}</p>
</li>
</ul>
</li>
</ul>
<h1 id="第二章、React面向组件编程"><a href="#第二章、React面向组件编程" class="headerlink" title="第二章、React面向组件编程"></a>第二章、React面向组件编程</h1><h2 id="1、基本理解和使用"><a href="#1、基本理解和使用" class="headerlink" title="1、基本理解和使用"></a>1、基本理解和使用</h2><h3 id="1-1渲染函数式组件标签的基本流程"><a href="#1-1渲染函数式组件标签的基本流程" class="headerlink" title="1.1渲染函数式组件标签的基本流程"></a>1.1渲染函数式组件标签的基本流程</h3><ul>
<li><p>1.React解析组件标签，找到了MyComponent组件。</p>
</li>
<li><p>2.发现组件是使用函数定义的，随后调用该函数，将返回的虚拟DOM转为真实的DOM，呈现在页面中。</p>
</li>
</ul>
<h3 id="1-2渲染类式组件标签的基本流程"><a href="#1-2渲染类式组件标签的基本流程" class="headerlink" title="1.2渲染类式组件标签的基本流程"></a>1.2渲染类式组件标签的基本流程</h3><ul>
<li><p>1.React解析组件标签，找到了MyComponent组件。</p>
</li>
<li><p>2.发现组件是使用类定义的，随后new出来该类（MyComponent）的实例，并通过该类实例调用到原型上的render方法。</p>
</li>
<li><p>3.将render返回的虚拟DOM转为真实的DOM，呈现在页面中。</p>
</li>
</ul>
<h2 id="2、组件三大核心属性"><a href="#2、组件三大核心属性" class="headerlink" title="2、组件三大核心属性"></a>2、组件三大核心属性</h2><h3 id="2-1、组件三大核心属性之state"><a href="#2-1、组件三大核心属性之state" class="headerlink" title="2.1、组件三大核心属性之state"></a>2.1、组件三大核心属性之state</h3><h4 id="2-1-1、理解"><a href="#2-1-1、理解" class="headerlink" title="2.1.1、理解"></a>2.1.1、理解</h4><ul>
<li><ol>
<li>state是组件对象最重要的属性, 值是对象(可以包含多个key-value的组合)</li>
</ol>
</li>
<li><ol start="2">
<li>组件被称为”状态机”, 通过更新组件的state来更新对应的页面显示(重新渲染组件)</li>
</ol>
</li>
</ul>
<h4 id="2-1-2、强烈注意"><a href="#2-1-2、强烈注意" class="headerlink" title="2.1.2、强烈注意"></a>2.1.2、强烈注意</h4><ul>
<li><ol>
<li>组件中render方法中的this为组件实例对象</li>
</ol>
</li>
<li><ol start="2">
<li>组件自定义的方法中this为undefined，如何解决？<ul>
<li>a) 强制绑定this: 通过函数对象的bind()</li>
</ul>
</li>
</ol>
<ul>
<li>b) 箭头函数</li>
</ul>
</li>
<li><ol start="3">
<li>状态数据，不能直接修改或更新</li>
</ol>
</li>
</ul>
<h4 id="2-1-3-编码操作"><a href="#2-1-3-编码操作" class="headerlink" title="2.1.3.编码操作"></a>2.1.3.编码操作</h4><ul>
<li>1.初始化状态</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.state = &#123;<span class="attr">isHot</span>:<span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>2.更新状态</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.setState(&#123;<span class="attr">isHot</span>:!isHot&#125;)</span><br></pre></td></tr></table></figure>



<h4 id="复习：展开运算符"><a href="#复习：展开运算符" class="headerlink" title="复习：展开运算符"></a>复习：展开运算符</h4><ul>
<li>在原生js中使用<ul>
<li>在函数中使用，不可以展开对象</li>
<li>构造字面量对象使用展开语法，是ES的新语法，需要用{}来包裹展开运算符</li>
</ul>
</li>
<li>在jsx中使用<ul>
<li>在react和babel双重作用下，可以在标签属性中使用，在其他地方也不可以使用</li>
</ul>
</li>
</ul>
<h3 id="2-2、组件三大核心属性之props"><a href="#2-2、组件三大核心属性之props" class="headerlink" title="2.2、组件三大核心属性之props"></a>2.2、组件三大核心属性之props</h3><h4 id="2-2-1-理解"><a href="#2-2-1-理解" class="headerlink" title="2.2.1. 理解"></a>2.2.1. 理解</h4><ul>
<li><ol>
<li>每个组件对象都会有props(properties的简写)属性</li>
</ol>
</li>
<li><ol start="2">
<li>组件标签的所有属性都保存在props中</li>
</ol>
</li>
</ul>
<h4 id="2-2-2-作用"><a href="#2-2-2-作用" class="headerlink" title="2.2.2.作用"></a>2.2.2.作用</h4><ul>
<li><ol>
<li>通过标签属性从组件外向组件内传递变化的数据</li>
</ol>
</li>
<li><ol start="2">
<li>注意: 组件内部不要修改props数据</li>
</ol>
</li>
</ul>
<h4 id="2-2-3-编码操作"><a href="#2-2-3-编码操作" class="headerlink" title="2.2.3.编码操作"></a>2.2.3.编码操作</h4><ul>
<li>1.内部读取某个属性值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.props.name</span><br></pre></td></tr></table></figure>

<ul>
<li><p>2.使用props对标签属性进行类型、必要性的限制</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person.propTypes = &#123;</span><br><span class="line">        <span class="attr">name</span>:PropTypes.string.isRequired,<span class="comment">//限制name必传，且为字符串</span></span><br><span class="line">        <span class="attr">age</span>:PropTypes.number,<span class="comment">//限制age为字符串</span></span><br><span class="line">        <span class="attr">sex</span>:PropTypes.string,<span class="comment">//限制sex为字符串</span></span><br><span class="line">        <span class="attr">speak</span>:PropTypes.func,<span class="comment">//限制speak为字函数</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>3.使用props给指定标签设置默认属性值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person.defaultProps = &#123;</span><br><span class="line">        <span class="attr">sex</span>:<span class="string">&#x27;男&#x27;</span>,<span class="comment">//sex默认值为男</span></span><br><span class="line">        <span class="attr">age</span>:<span class="number">18</span>,<span class="comment">//age默认值为18</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>4.扩展属性: 将对象的所有属性通过props传递</p>
<ul>
<li>展开运算符只能在react和babel双重作用下，在标签属性中使用，在其他地方也不可以使用<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(<span class="xml">&lt;Person&#123;...person/&gt;</span>.document.getElementById(<span class="string">&#x27;test3&#x27;</span>))</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="2-3、组件三大核心属性之refs"><a href="#2-3、组件三大核心属性之refs" class="headerlink" title="2.3、组件三大核心属性之refs"></a>2.3、组件三大核心属性之refs</h3><h4 id="2-4-2-理解"><a href="#2-4-2-理解" class="headerlink" title="2.4.2. 理解"></a>2.4.2. 理解</h4><ul>
<li>组件内的标签可以定义ref属性来标识自己</li>
</ul>
<h4 id="2-4-3-编码操作"><a href="#2-4-3-编码操作" class="headerlink" title="2.4.3.编码操作"></a>2.4.3.编码操作</h4><ul>
<li>1.字符串形式的ref——不推荐使用</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建方式</span></span><br><span class="line">&lt;input ref=<span class="string">&quot;input1&quot;</span> type=<span class="string">&quot;text&quot;</span> placeholder=<span class="string">&quot;点击按钮提示数据&quot;</span>/&gt;</span><br><span class="line"><span class="comment">//操作显示</span></span><br><span class="line"><span class="keyword">const</span> &#123;input1&#125; = <span class="built_in">this</span>.refs</span><br><span class="line">alert(input1.value)</span><br></pre></td></tr></table></figure>

<ul>
<li>2.回调形式的ref</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建方式</span></span><br><span class="line">&lt;input ref=&#123;<span class="function">(<span class="params">currentNode</span>)=&gt;</span>&#123;<span class="built_in">this</span>.input1 = currentNode&#125;&#125; type=<span class="string">&quot;text&quot;</span> placeholder=<span class="string">&quot;点击按钮提示数据&quot;</span>/&gt;</span><br><span class="line"><span class="comment">//操作显示</span></span><br><span class="line"><span class="keyword">const</span> &#123;input1&#125; = <span class="built_in">this</span></span><br><span class="line">alert(input1.value)</span><br></pre></td></tr></table></figure>

<ul>
<li>3.createRef创建ref容器——推荐使用</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建方式</span></span><br><span class="line">myRef = React.createRef()</span><br><span class="line">&lt;input ref=&#123;<span class="built_in">this</span>.myRef&#125; type=<span class="string">&quot;text&quot;</span> placeholder=<span class="string">&quot;点击按钮提示数据&quot;</span>/&gt;</span><br><span class="line"><span class="comment">//操作显示</span></span><br><span class="line">alert(<span class="built_in">this</span>.myRef.current.value)</span><br></pre></td></tr></table></figure>
<h4 id="2-4-4-事件处理"><a href="#2-4-4-事件处理" class="headerlink" title="2.4.4. 事件处理"></a>2.4.4. 事件处理</h4><ul>
<li>1.通过onXxx属性指定事件处理函数(注意大小写)<ul>
<li>1)React使用的是自定义(合成)事件, 而不是使用的原生DOM事件————为了更好的兼容性</li>
<li>2)React中的事件是通过事件委托方式处理的(委托给组件最外层的元素)————为了高效 </li>
</ul>
</li>
<li>2.通过event.target得到发生事件的DOM元素对象————不要过度使用ref<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  myRef2 = React.createRef()</span><br><span class="line">  showRightData = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    alert(<span class="built_in">this</span>.myRef2.current.value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;this.myRef2&#125;</span>  <span class="attr">onBlur</span>=<span class="string">&#123;this.showRightData&#125;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;失去焦点提示数据&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">          )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-4、收集表单数据"><a href="#2-4、收集表单数据" class="headerlink" title="2.4、收集表单数据"></a>2.4、收集表单数据</h3><h4 id="2-4-1-理解"><a href="#2-4-1-理解" class="headerlink" title="2.4.1 理解"></a>2.4.1 理解</h4><p>包含表单的组件分类</p>
<ul>
<li><ol>
<li>受控组件<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Login</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化状态</span></span><br><span class="line">        state = &#123;</span><br><span class="line">            <span class="attr">usename</span>:<span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="attr">password</span>:<span class="string">&quot;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 表单提交的回调</span></span><br><span class="line">        handSubmit = <span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">            event.preventDefault()<span class="comment">//阻止表单的默认提交事件</span></span><br><span class="line">            <span class="keyword">const</span> &#123;usename,password&#125; = <span class="built_in">this</span>.state</span><br><span class="line">            alert(<span class="string">`你输入的用户名是：<span class="subst">$&#123;usename&#125;</span>，你输入的密码是：<span class="subst">$&#123;password&#125;</span>`</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存用户名到状态中</span></span><br><span class="line">        saveUsename = <span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.setState(&#123;<span class="attr">usename</span>:event.target.value&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 保存密码到状态中</span></span><br><span class="line">        savePassword = <span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.setState(&#123;<span class="attr">password</span>:event.target.value&#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span>(</span><br><span class="line">               <span class="xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">onSubmit</span>=<span class="string">&#123;this.handSubmit&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">onChange</span>=<span class="string">&#123;this.saveUsename&#125;</span> <span class="attr">name</span>=<span class="string">&quot;usename&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placecholder</span>=<span class="string">&quot;请输入您的用户名&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="xml">                    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">onChange</span>=<span class="string">&#123;this.savePassword&#125;</span>  <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">placecholder</span>=<span class="string">&quot;密码&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">button</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">               <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><ol start="2">
<li>非受控组件:使用ref来标识<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Login</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        handSubmit = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">            event.preventDefault()<span class="comment">//阻止表单的默认提交事件</span></span><br><span class="line">            <span class="keyword">const</span> &#123;usename,password&#125; = <span class="built_in">this</span></span><br><span class="line">            alert(<span class="string">`你输入的用户名是：<span class="subst">$&#123;usename.value&#125;</span>，你输入的密码是：<span class="subst">$&#123;password.value&#125;</span>`</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span>(</span><br><span class="line">               <span class="xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">onSubmit</span>=<span class="string">&#123;this.handSubmit&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;(c)</span>=&gt;</span>&#123;this.usename = c&#125;&#125; name=&quot;usename&quot; type=&quot;text&quot; placecholder=&quot;请输入您的用户名&quot;/&gt;</span></span><br><span class="line"><span class="xml">                    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;(c)</span>=&gt;</span>&#123;this.password = c&#125;&#125; name=&quot;password&quot; type=&quot;password&quot; placecholder=&quot;密码&quot;/&gt;</span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">button</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">               <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h3 id="另外：高阶函数-amp-函数的柯里化"><a href="#另外：高阶函数-amp-函数的柯里化" class="headerlink" title="另外：高阶函数&amp;函数的柯里化"></a>另外：高阶函数&amp;函数的柯里化</h3><p>高阶函数：如果一个函数符合下面的两个规范中的任何一个，那该函数就是高阶函数。</p>
<ul>
<li>1.若A函数，接受的参数是一个函数，那么A就可以称之为高阶函数。</li>
<li>2.若A函数，调用的返回值依然是一个函数，那么A就可以称之为高阶函数</li>
<li>常见的高阶函数有：Promise、setTimeout、arr.map()</li>
</ul>
<p>函数的柯里化:通过函数调用继续返回函数的方式，实现多次接收参数最后统一处理的函数编码形式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span><span class="function">(<span class="params">b</span>)=&gt;</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="function">(<span class="params">c</span>)=&gt;</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> a+b+c</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-组件的生命周期"><a href="#2-5-组件的生命周期" class="headerlink" title="2.5 组件的生命周期"></a>2.5 组件的生命周期</h3><h4 id="2-5-1-理解"><a href="#2-5-1-理解" class="headerlink" title="2.5.1 理解"></a>2.5.1 理解</h4><ul>
<li><ol>
<li>组件从创建到死亡它会经历一些特定的阶段。</li>
</ol>
</li>
<li><ol start="2">
<li>React组件中包含一系列勾子函数(生命周期回调函数), 会在特定的时刻调用。</li>
</ol>
</li>
<li><ol start="3">
<li>我们在定义组件时，会在特定的生命周期回调函数中，做特定的工作。</li>
</ol>
</li>
</ul>
<h4 id="2-5-2-旧版流程图"><a href="#2-5-2-旧版流程图" class="headerlink" title="2.5.2 旧版流程图"></a>2.5.2 旧版流程图</h4><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1624537135752.png" alt="1624537135752"></p>
<ul>
<li>生命周期的三个阶段（旧）<ul>
<li><ol>
<li>初始化阶段: 由ReactDOM.render()触发—初次渲染</li>
<li>constructor()</li>
<li>componentWillMount()</li>
<li><strong>render()</strong> ====&gt;必用</li>
<li><strong>componentDidMount()</strong> ====&gt;常用<br>一般在这个勾子中做一些<strong>初始化</strong>的工作，例如：开启定时器、发送网络请求、订阅消息</li>
</ol>
</li>
<li><ol start="2">
<li>更新阶段: 由组件内部this.setSate()或父组件重新render触发</li>
<li>shouldComponentUpdate()</li>
<li>componentWillUpdate()</li>
<li><strong>render()</strong> ====&gt;必用</li>
<li>componentDidUpdate() </li>
</ol>
</li>
<li><ol start="3">
<li>卸载组件: 由ReactDOM.unmountComponentAtNode()触发</li>
<li><strong>componentWillUnmount()</strong>====&gt;常用<br>一般在这个勾子中做一些<strong>收尾</strong>的工作，例如：关闭定时器、取消订阅消息</li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="2-5-3-新版流程图"><a href="#2-5-3-新版流程图" class="headerlink" title="2.5.3 新版流程图"></a>2.5.3 新版流程图</h4><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1624537197754.png" alt="1624537197754"></p>
<ul>
<li><p>生命周期的三个阶段（新）</p>
<ul>
<li><ol>
<li><strong>初始化阶段</strong>: 由ReactDOM.render()触发—初次渲染</li>
<li>constructor()</li>
<li><strong>getDerivedStateFromProps</strong> </li>
<li>render()====&gt;必用</li>
<li>componentDidMount()====&gt;常用</li>
</ol>
<pre><code>一般在这个勾子中做一些**初始化**的工作，例如：开启定时器、发送网络请求、订阅消息
</code></pre>
</li>
<li>2.<strong>更新阶段</strong>:由组件内部this.setSate()或父组件重新render触发<ol>
<li><strong>getDerivedStateFromProps</strong></li>
<li>shouldComponentUpdate()</li>
<li>render()====&gt;必用</li>
<li><strong>getSnapshotBeforeUpdate</strong></li>
<li>componentDidUpdate()</li>
</ol>
</li>
<li>3.<strong>卸载组件</strong>:由ReactDOM.unmountComponentAtNode()触发<ol>
<li>componentWillUnmount()====&gt;常用<br> 一般在这个勾子中做一些<strong>收尾</strong>的工作，例如：关闭定时器、取消订阅消息</li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="2-5-4-重要的勾子"><a href="#2-5-4-重要的勾子" class="headerlink" title="2.5.4 重要的勾子"></a>2.5.4 重要的勾子</h4><ul>
<li>1.render：初始化渲染或更新渲染调用</li>
<li>2.componentDidMount：开启监听, 发送ajax请求</li>
<li>3.componentWillUnmount：做一些收尾工作, 如: 清理定时器</li>
</ul>
<h4 id="2-5-5将废弃的勾子"><a href="#2-5-5将废弃的勾子" class="headerlink" title="2.5.5将废弃的勾子"></a>2.5.5将废弃的勾子</h4><ul>
<li>1.componentWillMount</li>
<li>2.componentWillReceiveProps</li>
<li>3.componentWillUpdate<br>现在使用会出现警告，下一个大版本需要加上UNSAFE_前缀才能使用，以后可能会被彻底废弃，不建议使用。</li>
</ul>
<h4 id="2-5-6新更新的的勾子"><a href="#2-5-6新更新的的勾子" class="headerlink" title="2.5.6新更新的的勾子"></a>2.5.6新更新的的勾子</h4><ul>
<li><ol>
<li>getDerivedStateFromProps<br>state 的值在任何时候都取决于 props</li>
</ol>
</li>
<li><ol start="2">
<li>getSnapshotBeforeUpdate<br>用法并不常见</li>
</ol>
</li>
</ul>
<h3 id="关于key的经典面试题"><a href="#关于key的经典面试题" class="headerlink" title="关于key的经典面试题"></a>关于key的经典面试题</h3><h4 id="（1）react-vue中的key有什么作用？（key的内部原理是什么？）"><a href="#（1）react-vue中的key有什么作用？（key的内部原理是什么？）" class="headerlink" title="（1）react/vue中的key有什么作用？（key的内部原理是什么？）"></a>（1）react/vue中的key有什么作用？（key的内部原理是什么？）</h4><h4 id="（2）为什么遍历列表时，key最好不要用index？"><a href="#（2）为什么遍历列表时，key最好不要用index？" class="headerlink" title="（2）为什么遍历列表时，key最好不要用index？"></a>（2）为什么遍历列表时，key最好不要用index？</h4><ul>
<li>1、虚拟DOM中key的作用： <ul>
<li>1.简单来说：key是虚拟DOM对象的标识，在更新显示时key起着极其重要的作用。</li>
<li>2.详细的说：当状态 中的数据发生改变时，react会根据【新数据】生成【新的修DOM】，随后React进行【新虚拟DOM】与【旧虚拟DOM】的diffing比较，比较规则如下：<ul>
<li>A、旧虚拟DOM中找到了与新虚拟DOM相同的key：<ul>
<li>a、若虚拟DOM中内容没变，直接使用之前的真实DOM</li>
<li>b、若虚拟DOM中内容变了，则生成新的真是DOM，随后替换掉页面中之前的真实DOM</li>
</ul>
</li>
<li>B、旧虚拟DOM中未找到与新虚拟DOM相同的key<ul>
<li>根据数据创建新的真实虚拟DOM</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>2、用index作为key可能会引发的问题：<ul>
<li>1.若对数据进行：逆序添加、逆序删除等破坏顺序操作：<ul>
<li>会产生没有必要的真实DOM更新 ==&gt; 界面效果没有问题，但效率低下</li>
</ul>
</li>
<li>2.若结构中还包含输入类的DOM：<ul>
<li>会产生错误DOM更新 ==&gt; 界面有问题</li>
</ul>
</li>
<li>3.注意！如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅仅用于渲染列表、用于展示，使用index作为key时没有问题的。</li>
</ul>
</li>
</ul>
<h1 id="第三章-React应用-基于React脚手架"><a href="#第三章-React应用-基于React脚手架" class="headerlink" title="第三章 React应用(基于React脚手架)"></a>第三章 React应用(基于React脚手架)</h1><h2 id="3-1-使用create-react-app-创建-react-应用"><a href="#3-1-使用create-react-app-创建-react-应用" class="headerlink" title="3.1 使用create-react-app 创建 react 应用"></a>3.1 使用create-react-app 创建 react 应用</h2><h3 id="3-1-1-react-脚手架"><a href="#3-1-1-react-脚手架" class="headerlink" title="3.1.1 react 脚手架"></a>3.1.1 react 脚手架</h3><ul>
<li>1.xxx脚手架: 用来帮助程序员快速创建一个基于xxx库的模板项目<ul>
<li>1.包含了所有需要的配置（语法检查、jsx编译、devServer…）</li>
<li>2.下载好了所有相关的依赖</li>
<li>3.可以直接运行一个简单效果</li>
</ul>
</li>
<li>2.react提供了一个用于创建react项目的脚手架库:create-react-app</li>
<li>3.项目的整体技术架构为:  react + webpack + es6 + eslint</li>
<li>4.使用脚手架开发的项目的特点: 模块化, 组件化, 工程化</li>
</ul>
<h3 id="3-1-2创建项目并启动"><a href="#3-1-2创建项目并启动" class="headerlink" title="3.1.2创建项目并启动"></a>3.1.2创建项目并启动</h3><ul>
<li><strong>第一步</strong>，全局安装：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g create-react-app</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>第二步</strong>，切换到想创项目的目录：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create-react-app hello-react</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>第三步</strong>，进入项目文件夹：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd hello-react</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>第四步</strong>，启动项目：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure>

<h3 id="3-1-3-react脚手架项目结构"><a href="#3-1-3-react脚手架项目结构" class="headerlink" title="3.1.3 react脚手架项目结构"></a>3.1.3 react脚手架项目结构</h3><ul>
<li>public —- 静态资源文件夹<br>favicon.icon —— 网站页签图标<br><strong>index.html ——– 主页面</strong><br>logo192.png ——- logo图<br>logo512.png ——- logo图<br>manifest.json —– 应用加壳的配置文件<br>robots.txt ——– 爬虫协议文件</li>
<li>src —- 源码文件夹<br>App.css ——– App组件的样式<br>  <strong>App.js ——— App组件</strong><br>  App.test.js —- 用于给App做测试<br>  index.css —— 样式<br>  <strong>index.js ——- 入口文件</strong><br>  logo.svg ——- logo图<br>  reportWebVitals.js— 页面性能分析文件(需要web-vitals库的支持)<br>  setupTests.js—- 组件单元测试的文件(需要jest-dom库的支持)0</li>
</ul>
<h3 id="3-1-4-功能界面的组件化编码流程（通用）"><a href="#3-1-4-功能界面的组件化编码流程（通用）" class="headerlink" title="3.1.4 功能界面的组件化编码流程（通用）"></a>3.1.4 功能界面的组件化编码流程（通用）</h3><ul>
<li><ol>
<li>拆分组件: 拆分界面,抽取组件</li>
</ol>
</li>
<li><ol start="2">
<li>实现静态组件: 使用组件实现静态页面效果</li>
</ol>
</li>
<li><ol start="3">
<li>实现动态组件</li>
</ol>
<ul>
<li>3.1 动态显示初始化数据<ul>
<li>3.1.1 数据类型</li>
<li>3.1.2 数据名称</li>
<li>3.1.2 保存在哪个组件?</li>
</ul>
</li>
<li>3.2 交互(从绑定事件监听开始)</li>
</ul>
</li>
</ul>
<h2 id="3-2-组件的组合使用-案例-TodoList"><a href="#3-2-组件的组合使用-案例-TodoList" class="headerlink" title="3.2 组件的组合使用-案例-TodoList"></a>3.2 组件的组合使用-案例-TodoList</h2><h3 id="案例相关知识点"><a href="#案例相关知识点" class="headerlink" title="案例相关知识点"></a>案例相关知识点</h3><ul>
<li><ol>
<li>拆分组件、实现静态组件，注意：添加类名、style的写法</li>
</ol>
<ul>
<li>添加类名————className</li>
<li><code>style = &#123;&#123;background:'white'&#125;&#125;</code></li>
</ul>
</li>
<li><ol start="2">
<li>动态初始化列表，如何确定将数据放在哪个组件的state中？</li>
</ol>
<ul>
<li>某个组件使用：放在其自身的state中</li>
<li>某些组件使用：放在他们共同的父组件state中（）官方称次操作为：状态提升</li>
</ul>
</li>
<li><ol start="3">
<li>关于父子之间的通信：</li>
</ol>
<ul>
<li>【父组件】给【子组件】传递数据：通过props传递</li>
<li>【子组件】给【父组件】传递数据：通过props传递，要求父提前给子传递一个函数</li>
</ul>
</li>
<li><ol start="4">
<li>注意 defaultChecked 和 checked 的区别，类似的还有：defaultValue 和 value：</li>
</ol>
<ul>
<li>defaultChecked ：只会在第一次加载是改变 checked 的布尔值</li>
<li>checked ：会保持最后一次的变化</li>
</ul>
</li>
<li><ol start="5">
<li>状态在哪里，操作状态的方法就在哪里</li>
</ol>
</li>
</ul>
<h1 id="第四章-React-Ajax"><a href="#第四章-React-Ajax" class="headerlink" title="第四章 React Ajax"></a>第四章 React Ajax</h1><h2 id="4-1-理解"><a href="#4-1-理解" class="headerlink" title="4.1. 理解"></a>4.1. 理解</h2><h3 id="4-1-1-前置说明"><a href="#4-1-1-前置说明" class="headerlink" title="4.1.1 前置说明"></a>4.1.1 前置说明</h3><ul>
<li>1.React本身只关注于界面, 并不包含发送ajax请求的代码</li>
<li>2.前端应用需要通过ajax请求与后台进行交互(json数据)</li>
<li>3.react应用中需要集成第三方ajax库(或自己封装)</li>
</ul>
<h3 id="4-1-2-常用的ajax请求库"><a href="#4-1-2-常用的ajax请求库" class="headerlink" title="4.1.2 常用的ajax请求库"></a>4.1.2 常用的ajax请求库</h3><ul>
<li>1.jQuery: 比较重, 如果需要另外引入不建议使用</li>
<li>2.axios: 轻量级, 建议使用<br>1)封装XmlHttpRequest对象的ajax<ol start="2">
<li>promise风格</li>
<li>可以用在浏览器端和node服务器端</li>
</ol>
</li>
</ul>
<h2 id="4-2-axios"><a href="#4-2-axios" class="headerlink" title="4.2 axios"></a>4.2 axios</h2><ul>
<li><strong>第一步：</strong>安装axios</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install axios</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>第二步：</strong>引入axios</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-2-1-脚手架配置代理————方法一"><a href="#4-2-1-脚手架配置代理————方法一" class="headerlink" title="4.2.1 脚手架配置代理————方法一"></a>4.2.1 脚手架配置代理————方法一</h3><p>配置单个代理<br>说明：<br>    1. 优点：配置简单，前端请求资源时可以不加任何前缀。<br>        2. 缺点：不能配置多个代理。<br>        3. 工作方式：上述方式配置代理，当请求了3000不存在的资源时，那么该请求会转发给5000 （优先匹配前端资源）</p>
<ul>
<li><strong>第三步：</strong>编写请求</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">&#x27;在这里写代理请求的地址&#x27;</span>).then(</span><br><span class="line">        <span class="function"><span class="params">response</span> =&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="string">&#x27;成功了&#x27;</span>,response);&#125;,</span><br><span class="line">        <span class="function"><span class="params">error</span> =&gt;</span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;失败了&#x27;</span>,error);&#125;</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>第四步：</strong>解决跨域问题（ajax的同源策略引起）——代理:即找一个“中间人”<br>找到你要运行文件的<strong>package.json</strong>的文件加上如下代码</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;proxy&quot;</span>:<span class="string">&quot;在这里写实际的请求的地址&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-2-2-脚手架配置代理————方法二"><a href="#4-2-2-脚手架配置代理————方法二" class="headerlink" title="4.2.2 脚手架配置代理————方法二"></a>4.2.2 脚手架配置代理————方法二</h3><p>配置多个代理<br>说明：<br>    1. 优点：可以配置多个代理，可以灵活的控制请求是否走代理。<br>    2. 缺点：配置繁琐，前端请求资源时必须加前缀。</p>
<ul>
<li><strong>第三步：</strong>编写请求</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">&#x27;http://localhost:3000/api1/students&#x27;</span>).then(</span><br><span class="line">        <span class="function"><span class="params">response</span> =&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="string">&#x27;成功了&#x27;</span>,response);&#125;,</span><br><span class="line">        <span class="function"><span class="params">error</span> =&gt;</span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;失败了&#x27;</span>,error);&#125;</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>第四步：</strong>解决跨域问题（ajax的同源策略引起）——代理:即找一个“中间人”<br>在src目录下创建一个<strong>setupProxy.js</strong>在该文件中是编写commonjs的语法</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="built_in">require</span>(<span class="string">&#x27;http-proxy-middleware&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">app</span>) </span>&#123;</span><br><span class="line">  app.use(</span><br><span class="line">    proxy(<span class="string">&#x27;/api1&#x27;</span>, &#123;  <span class="comment">//api1是需要转发的请求(所有带有/api1前缀的请求都会转发给5000)</span></span><br><span class="line">      <span class="attr">target</span>: <span class="string">&#x27;http://localhost:5000&#x27;</span>, <span class="comment">//配置转发目标地址(能返回数据的服务器地址)</span></span><br><span class="line">      <span class="attr">changeOrigin</span>: <span class="literal">true</span>, <span class="comment">//控制服务器接收到的请求头中host字段的值</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      	changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000</span></span><br><span class="line"><span class="comment">      	changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:3000</span></span><br><span class="line"><span class="comment">      	changeOrigin默认值为false，但我们一般将changeOrigin值设为true</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="attr">pathRewrite</span>: &#123;<span class="string">&#x27;^/api1&#x27;</span>: <span class="string">&#x27;&#x27;</span>&#125; <span class="comment">//去除请求前缀，保证交给后台服务器的是正常请求地址(必须配置)</span></span><br><span class="line">    &#125;),</span><br><span class="line">    proxy(<span class="string">&#x27;/api2&#x27;</span>, &#123; </span><br><span class="line">      <span class="attr">target</span>: <span class="string">&#x27;http://localhost:5001&#x27;</span>,</span><br><span class="line">      <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">pathRewrite</span>: &#123;<span class="string">&#x27;^/api2&#x27;</span>: <span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-3-axios的使用————github-用户搜索"><a href="#4-3-axios的使用————github-用户搜索" class="headerlink" title="4.3 axios的使用————github 用户搜索"></a>4.3 axios的使用————github 用户搜索</h2><h3 id="案例相关知识点-1"><a href="#案例相关知识点-1" class="headerlink" title="案例相关知识点"></a>案例相关知识点</h3><ul>
<li><ol>
<li>设计状态时要考虑全面，例如带有网络请求的组件，要考虑请求失败怎么办</li>
</ol>
<ul>
<li>欢迎语</li>
<li>加载中loading…提示</li>
<li>数据展示</li>
<li>请求失败提醒</li>
</ul>
</li>
<li><ol start="2">
<li>ES6小知识点：解构赋值的连续解构+重命名</li>
</ol>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//连续解构</span></span><br><span class="line"><span class="keyword">const</span> &#123;<span class="attr">a</span>:&#123;b&#125;&#125; = obj</span><br><span class="line"><span class="comment">//取用</span></span><br><span class="line">b</span><br><span class="line"><span class="comment">//连续解构+重命名</span></span><br><span class="line"><span class="keyword">const</span> &#123;<span class="attr">keyWordElement</span>:&#123;<span class="attr">value</span>:keyWord&#125;&#125; = <span class="built_in">this</span></span><br><span class="line"><span class="comment">//取用</span></span><br><span class="line">keyWord</span><br></pre></td></tr></table></figure>

<ul>
<li><ol start="3">
<li>三元运算符的嵌套使用</li>
</ol>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">isFirst ? <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>欢迎使用，输入关键字，税后点击搜索<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span> : isLoading ? <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>loading...<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span> : err ? <span class="xml"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">style</span>=<span class="string">&#123;&#123;color:</span>&#x27;<span class="attr">red</span>&#x27;&#125;&#125;&gt;</span>&#123;err&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span> : users.map(<span class="function">(<span class="params">userObj</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&#123;userObj.id&#125;</span> <span class="attr">className</span>=<span class="string">&quot;card&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">rel</span>=<span class="string">&quot;noreferrer&quot;</span> <span class="attr">href</span>=<span class="string">&#123;userObj.html_url&#125;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">alt</span>=<span class="string">&quot;head_portrait&quot;</span> <span class="attr">src</span>=<span class="string">&#123;userObj.avatar_url&#125;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;width:</span>&#x27;<span class="attr">100px</span>&#x27;&#125;&#125;/&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">&quot;card-text&quot;</span>&gt;</span>&#123;userObj.login&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><ol start="4">
<li>消息订阅与发布机制</li>
</ol>
<ul>
<li><ol>
<li>先订阅，再发布（理解：隔空喊话的感觉）</li>
</ol>
</li>
<li><ol start="2">
<li>适用于任意组件间通信</li>
</ol>
</li>
<li><ol start="3">
<li>要在组件的componentWillUnmount中取消订阅</li>
</ol>
</li>
</ul>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//订阅</span></span><br><span class="line"><span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 标识订阅，以便后面的取消订阅</span></span><br><span class="line">    <span class="built_in">this</span>.token = PubSub.subscribe(<span class="string">&#x27;xiaoxi&#x27;</span>,<span class="function">(<span class="params">_,stateObj</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.setState(stateObj)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发布</span></span><br><span class="line">PubSub.publish(<span class="string">&#x27;xiaoxi&#x27;</span>,&#123;<span class="attr">isFirst</span>:<span class="literal">false</span>,<span class="attr">isLoading</span>:<span class="literal">true</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//取消订阅</span></span><br><span class="line"><span class="function"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    PubSub.unsubscribe(<span class="built_in">this</span>.token)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><ol start="5">
<li>使用axios来完成网络请求</li>
</ol>
</li>
</ul>
<h2 id="4-4-消息订阅-发布机制"><a href="#4-4-消息订阅-发布机制" class="headerlink" title="4.4 消息订阅-发布机制"></a>4.4 消息订阅-发布机制</h2><p>publishi发布消息出去，消息名和携带的消息，然后subscribe去订阅这个消息，然后回调那个回调函数，msg就是消息名，data就是那个数据</p>
<ul>
<li><ol>
<li>工具库: PubSubJS</li>
</ol>
</li>
<li><ol start="2">
<li>下载: npm install pubsub-js –save</li>
</ol>
</li>
<li><ol start="3">
<li>使用: </li>
</ol>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1) 引入 </span></span><br><span class="line"><span class="keyword">import</span> PubSub <span class="keyword">from</span> <span class="string">&#x27;pubsub-js&#x27;</span> </span><br><span class="line"><span class="comment">//2) 订阅 </span></span><br><span class="line">PubSub.subscribe(<span class="string">&#x27;msg&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123; &#125;);</span><br><span class="line"><span class="comment">//3) 发布消息</span></span><br><span class="line">PubSub.publish(<span class="string">&#x27;msg&#x27;</span>, data) </span><br><span class="line"><span class="comment">//4) 标识订阅</span></span><br><span class="line"><span class="keyword">const</span> token = PubSub.subscribe(<span class="string">&#x27;msg&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123; &#125;);</span><br><span class="line"><span class="comment">//5) 取消订阅</span></span><br><span class="line">PubSub.unsubscribe(token);</span><br></pre></td></tr></table></figure>





<h1 id="第五章-React路由"><a href="#第五章-React路由" class="headerlink" title="第五章 React路由"></a>第五章 React路由</h1><h2 id="5-1-相关理解"><a href="#5-1-相关理解" class="headerlink" title="5.1 相关理解"></a>5.1 相关理解</h2><h3 id="5-1-1-SPA的理解"><a href="#5-1-1-SPA的理解" class="headerlink" title="5.1.1. SPA的理解"></a>5.1.1. SPA的理解</h3><ul>
<li><ol>
<li>单页Web应用（single page web application，SPA）。</li>
</ol>
</li>
<li><ol start="2">
<li>整个应用只有<strong>一个完整的页面</strong>。</li>
</ol>
</li>
<li><ol start="3">
<li>点击页面中的链接<strong>不会刷新页面</strong>，只会做页面的<strong>局部更新</strong>。</li>
</ol>
</li>
<li><ol start="4">
<li>数据都需要通过ajax请求获取, 并在前端<strong>异步展现</strong>。</li>
</ol>
</li>
<li><ol start="5">
<li>总结一下子：单页面多组件</li>
</ol>
</li>
</ul>
<h3 id="5-1-2-路由的理解"><a href="#5-1-2-路由的理解" class="headerlink" title="5.1.2. 路由的理解"></a>5.1.2. 路由的理解</h3><h4 id="1-什么是路由"><a href="#1-什么是路由" class="headerlink" title="1.什么是路由?"></a>1.什么是路由?</h4><ul>
<li><ol>
<li>一个路由就是一个映射关系(key:value)</li>
</ol>
</li>
<li><ol start="2">
<li>key为路径, value可能是function或component</li>
</ol>
</li>
</ul>
<h4 id="2-路由分类"><a href="#2-路由分类" class="headerlink" title="2.路由分类"></a>2.路由分类</h4><ul>
<li><ol>
<li>后端路由：</li>
</ol>
<ul>
<li>1)理解： value是function, 用来处理客户端提交的请求。</li>
<li>2)注册路由： router.get(path, function(req, res))</li>
<li>3)工作过程：当node接收到一个请求时, 根据请求路径找到匹配的路由, 调用路由中的函数来处理请求, 返回响应数据</li>
</ul>
</li>
<li><ol start="2">
<li>前端路由：</li>
</ol>
<ul>
<li>1)浏览器端路由，value是component，用于展示页面内容。</li>
<li>2)注册路由: <Route path="/test" component={Test}></li>
<li>3)工作过程：当浏览器的path变为/test时, 当前路由组件就会变为Test组件</li>
</ul>
</li>
</ul>
<h2 id="5-2-路由的使用"><a href="#5-2-路由的使用" class="headerlink" title="5.2 路由的使用"></a>5.2 路由的使用</h2><h3 id="5-2-1-安装react-router-dom"><a href="#5-2-1-安装react-router-dom" class="headerlink" title="5.2.1 安装react-router-dom"></a>5.2.1 安装react-router-dom</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install react-router-dom</span><br></pre></td></tr></table></figure>

<h3 id="5-2-2-路由的基本使用"><a href="#5-2-2-路由的基本使用" class="headerlink" title="5.2.2 路由的基本使用"></a>5.2.2 路由的基本使用</h3><ul>
<li><ol>
<li>明确好界面中的导航区、展示区</li>
</ol>
</li>
<li><ol start="2">
<li>导航区的a标签改为Link标签</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=<span class="string">&quot;/XXXX&quot;</span>&gt;Dome&lt;/Link&gt;</span><br></pre></td></tr></table></figure></li>
<li><ol start="3">
<li>展示区写Route标签进行路径的匹配</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=<span class="string">&#x27;/XXXX&#x27;</span> component=&#123;Demo&#125;/&gt;</span><br></pre></td></tr></table></figure></li>
<li><ol start="4">
<li><App>的最外侧包裹了一个<BrowserRouter>或<HashRouter></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;BrowserRouter&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">App</span>/&gt;</span></span></span><br><span class="line">&lt;/BrowserRouter&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-2-3-路由组件和一般组件"><a href="#5-2-3-路由组件和一般组件" class="headerlink" title="5.2.3 路由组件和一般组件"></a>5.2.3 路由组件和一般组件</h3><ul>
<li><ol>
<li>写法不同：</li>
</ol>
<ul>
<li>一般组件：<Dome/></li>
<li>路由组件：<Route path="/Dome" component={Dome}/></li>
</ul>
</li>
<li><ol start="2">
<li>存放位置不同：</li>
</ol>
<ul>
<li>一般组件：components</li>
<li>路由组件：pages</li>
</ul>
</li>
<li><ol start="3">
<li>接受的props不同：</li>
</ol>
<ul>
<li>一般组件：写组件标签时传递了什么，就能收到说明</li>
<li>路由组件：接收到三个固定的属性<ul>
<li>history:<pre><code>go: ƒ go(n)
goBack: ƒ goBack()
goForward: ƒ goForward()
push: ƒ push(path, state)
replace: ƒ replace(path, state)
</code></pre>
</li>
<li>location:<pre><code>pathname: &quot;/about&quot;
search: &quot;&quot;
state: undefined
</code></pre>
</li>
<li>match:<pre><code>params: &#123;&#125;
path: &quot;/about&quot;
url: &quot;/about&quot;
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-2-4-NavLink和封装NavLink"><a href="#5-2-4-NavLink和封装NavLink" class="headerlink" title="5.2.4 NavLink和封装NavLink"></a>5.2.4 NavLink和封装NavLink</h3><ul>
<li><ol>
<li>NavLink可以实现路由链接的高亮，通过activeClassName指定样式名</li>
</ol>
</li>
<li><ol start="2">
<li>标签体内容是一个特殊的标签属性——children</li>
</ol>
</li>
<li><ol start="3">
<li>通过this.props.children可以获取标签体内容</li>
</ol>
</li>
</ul>
<h3 id="5-2-5-Switch的使用"><a href="#5-2-5-Switch的使用" class="headerlink" title="5.2.5 Switch的使用"></a>5.2.5 Switch的使用</h3><ul>
<li><ol>
<li>通常情况下，path和component时一一对应的关系</li>
</ol>
</li>
<li><ol start="2">
<li>Switch可以提高路由匹配效率（单一匹配）</li>
</ol>
</li>
</ul>
<h3 id="5-2-6-解决多级路由刷新页面样式丢失问题的方法"><a href="#5-2-6-解决多级路由刷新页面样式丢失问题的方法" class="headerlink" title="5.2.6 解决多级路由刷新页面样式丢失问题的方法"></a>5.2.6 解决多级路由刷新页面样式丢失问题的方法</h3><ul>
<li><ol>
<li>更改请求样式的路径（一）——只适用于在react脚手架中使用，其他地方不可用（常用）</li>
</ol>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//原始</span><br><span class="line">href=&quot;./css/bootstrap.css&quot;</span><br><span class="line">//修改后</span><br><span class="line">href=&quot;%PUBLIC_URL%/css/bootstrap.css&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><ol start="2">
<li>更改请求样式的路径（二）——一般选择该方式（常用）</li>
</ol>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//原始</span><br><span class="line">href=&quot;./css/bootstrap.css&quot;</span><br><span class="line">//修改后</span><br><span class="line">href=&quot;/css/bootstrap.css&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>. 更改路由器<br>将BrowserRouter改为HashRouter</li>
</ul>
<h3 id="5-2-6-路由的严格匹配与模糊匹配"><a href="#5-2-6-路由的严格匹配与模糊匹配" class="headerlink" title="5.2.6 路由的严格匹配与模糊匹配"></a>5.2.6 路由的严格匹配与模糊匹配</h3><ul>
<li><ol>
<li>默认使用的事模糊匹配（简单记：【输入的路径】必须严格等于【匹配的路径】，且顺序必须相同）</li>
</ol>
</li>
<li><ol start="2">
<li>开启 严格匹配</li>
</ol>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 方式一 --&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">exact</span>=<span class="string">&#123;true&#125;</span> <span class="attr">path</span>=<span class="string">&quot;/about&quot;</span> <span class="attr">component</span>=<span class="string">&#123;About&#125;/</span>&gt;</span></span></span><br><span class="line">&lt;!-- 方式二 --&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">exact</span> <span class="attr">path</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Home&#125;/</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><ol start="3">
<li>严格匹配不要随便开启，需要再开，有些时候开启会导致无法继续匹配二级路由</li>
</ol>
</li>
</ul>
<h3 id="5-2-7-Redirect的使用"><a href="#5-2-7-Redirect的使用" class="headerlink" title="5.2.7 Redirect的使用"></a>5.2.7 Redirect的使用</h3><ul>
<li>一般写在所有路由注册的最下方，当所有路由都不匹配时，跳转到Redirect指定的路由</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Home&#125;/</span>&gt;</span></span></span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/about&quot;</span> <span class="attr">component</span>=<span class="string">&#123;About&#125;/</span>&gt;</span></span> </span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">to</span>=<span class="string">&quot;/home&quot;</span>/&gt;</span></span></span><br><span class="line">&lt;/Switch&gt;</span><br></pre></td></tr></table></figure>



<h2 id="5-3-嵌套路由"><a href="#5-3-嵌套路由" class="headerlink" title="5.3 嵌套路由"></a>5.3 嵌套路由</h2><ul>
<li><ol>
<li>注册子路由时要写上父路由的path值</li>
</ol>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 父路由 --&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Home&#125;/</span>&gt;</span></span></span><br><span class="line">&lt;!-- 子路由 --&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/home/news&quot;</span> <span class="attr">component</span>=<span class="string">&#123;News&#125;/</span>&gt;</span></span> </span><br></pre></td></tr></table></figure>

<ul>
<li><ol start="2">
<li>路由的匹配是按照注册路由的顺序进行的</li>
</ol>
</li>
</ul>
<h2 id="5-4-向路由组件传递参数数据"><a href="#5-4-向路由组件传递参数数据" class="headerlink" title="5.4 向路由组件传递参数数据"></a>5.4 向路由组件传递参数数据</h2><h3 id="5-4-1-params参数"><a href="#5-4-1-params参数" class="headerlink" title="5.4.1 params参数"></a>5.4.1 params参数</h3><p>路由链接（携带参数）：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;LInk to=<span class="string">&quot;/demo/test/tom/18&quot;</span>&gt;详情&lt;/Link&gt;</span><br></pre></td></tr></table></figure>

<p>注册路由（声明接收）：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=<span class="string">&quot;/demo/test/:name/:age&quot;</span> component=&#123;Test&#125;/&gt;</span><br></pre></td></tr></table></figure>

<p>接收参数：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;name,age&#125; = <span class="built_in">this</span>.props.match.params</span><br></pre></td></tr></table></figure>

<h3 id="5-4-2-search参数"><a href="#5-4-2-search参数" class="headerlink" title="5.4.2 search参数"></a>5.4.2 search参数</h3><p>路由链接（携带参数）：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;LInk to=<span class="string">&quot;/demo/test?name=tom&amp;age=18&quot;</span>&gt;详情&lt;/Link&gt;</span><br></pre></td></tr></table></figure>

<p>注册路由（无需声明接收，正常注册即可）：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=<span class="string">&quot;/demo/test&quot;</span> component=&#123;Test&#125;/&gt;</span><br></pre></td></tr></table></figure>

<p>接收参数：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入querystring库</span></span><br><span class="line"><span class="keyword">import</span> qs <span class="keyword">from</span> <span class="string">&#x27;querystring&#x27;</span></span><br><span class="line"><span class="comment">//接收参数</span></span><br><span class="line"><span class="keyword">const</span> &#123;search&#125; = <span class="built_in">this</span>.props.location</span><br><span class="line"><span class="keyword">const</span> &#123;name,age&#125; = qs.parse(search.slice(<span class="number">1</span>))</span><br><span class="line"><span class="comment">//str.slice(1)是从该字符的第二个字符开始截取，此处是为了去掉问号</span></span><br><span class="line"><span class="comment">//备注：获取到的search是urlencoded编码字符串，需要借助querystring解析</span></span><br></pre></td></tr></table></figure>

<h3 id="5-4-2-state参数"><a href="#5-4-2-state参数" class="headerlink" title="5.4.2 state参数"></a>5.4.2 state参数</h3><p>路由链接（携带参数）：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;LInk to=&#123;&#123;<span class="attr">pathName</span>:<span class="string">&quot;/demo/test&quot;</span>,<span class="attr">state</span>:&#123;<span class="attr">name</span>:<span class="string">&#x27;tom&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;&#125;&#125;&gt;详情&lt;/Link&gt;</span><br></pre></td></tr></table></figure>

<p>注册路由（无需声明接收，正常注册即可）：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=<span class="string">&quot;/demo/test&quot;</span> component=&#123;Test&#125;/&gt;</span><br></pre></td></tr></table></figure>

<p>接收参数：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;name,age&#125; = <span class="built_in">this</span>.props.location.state || &#123;&#125;</span><br><span class="line"><span class="comment">// ||&#123;&#125;这部分代码是为了防止复制地址，在新的标签页打开是参数丢失而报错</span></span><br><span class="line"><span class="comment">//备注：在元标签页刷新也可以保留住参数</span></span><br></pre></td></tr></table></figure>



<h2 id="5-5-多种路由跳转方式"><a href="#5-5-多种路由跳转方式" class="headerlink" title="5.5 多种路由跳转方式"></a>5.5 多种路由跳转方式</h2><h3 id="5-5-1-push"><a href="#5-5-1-push" class="headerlink" title="5.5.1 push"></a>5.5.1 push</h3><p>压栈模式，会留下痕迹</p>
<h3 id="5-5-2-replace"><a href="#5-5-2-replace" class="headerlink" title="5.5.2 replace"></a>5.5.2 replace</h3><p>替换模式，不会留下痕迹</p>
<h3 id="5-5-3-编程式路由导航"><a href="#5-5-3-编程式路由导航" class="headerlink" title="5.5.3 编程式路由导航"></a>5.5.3 编程式路由导航</h3><p>借助this.props.history对象上的API对操作路由跳转、前进、后退</p>
<ul>
<li>this.props.history.push()//push查看</li>
<li>this.props.history.replace()//replace查看</li>
<li>this.props.history.goBack()//回退</li>
<li>this.props.history.goForward()//前进</li>
<li>this.props.history.go(i)//灵活控制前进还是后退，i&gt;0是前进i步,i=0是刷新,i&lt;0是后退i步</li>
</ul>
<h3 id="5-5-4-withRouter"><a href="#5-5-4-withRouter" class="headerlink" title="5.5.4 withRouter"></a>5.5.4 withRouter</h3><ul>
<li>withRouter可以加工一般组件，让一般组件具备路由组件所特有的API</li>
<li>withRouter的返回值是一个新组件</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 引入 --&gt;</span><br><span class="line"><span class="keyword">import</span> &#123;withRouter&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line">&lt;!-- 操作暴露 --&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withRouter(Header)</span><br></pre></td></tr></table></figure>





<h1 id="第六章-React-UI组件库"><a href="#第六章-React-UI组件库" class="headerlink" title="第六章 React UI组件库"></a>第六章 React UI组件库</h1><h2 id="6-1-流行的开源React-UI组件库"><a href="#6-1-流行的开源React-UI组件库" class="headerlink" title="6.1 流行的开源React UI组件库"></a>6.1 流行的开源React UI组件库</h2><h3 id="6-1-1-material-ui-国外"><a href="#6-1-1-material-ui-国外" class="headerlink" title="6.1.1  material-ui(国外)"></a>6.1.1  material-ui(国外)</h3><p>1.官网: <a target="_blank" rel="noopener" href="http://www.material-ui.com/#/">http://www.material-ui.com/#/</a><br>2.github: <a target="_blank" rel="noopener" href="https://github.com/callemall/material-ui">https://github.com/callemall/material-ui</a></p>
<h3 id="6-1-2-ant-design-国内蚂蚁金服"><a href="#6-1-2-ant-design-国内蚂蚁金服" class="headerlink" title="6.1.2  ant-design(国内蚂蚁金服)"></a>6.1.2  ant-design(国内蚂蚁金服)</h3><p>1.官网: <a target="_blank" rel="noopener" href="https://ant.design/index-cn">https://ant.design/index-cn</a><br>2.Github: <a target="_blank" rel="noopener" href="https://github.com/ant-design/ant-design/">https://github.com/ant-design/ant-design/</a></p>
<h3 id="6-1-3-使用-ant-design-国内蚂蚁金服"><a href="#6-1-3-使用-ant-design-国内蚂蚁金服" class="headerlink" title="6.1.3 使用 ant-design(国内蚂蚁金服)"></a>6.1.3 使用 ant-design(国内蚂蚁金服)</h3><p>主要是对国内的react-ul库展开讲述</p>
<ul>
<li><ol>
<li>下载</li>
</ol>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install antd</span><br></pre></td></tr></table></figure>

<ul>
<li><ol start="2">
<li>使用例子-全部引入</li>
</ol>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="comment">//引入antd</span></span><br><span class="line"><span class="keyword">import</span> &#123; Button,DatePicker &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span>;</span><br><span class="line"><span class="comment">//整体引入antd的样式库</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;antd/dist/antd.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; RangePicker &#125; = DatePicker;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">onChange</span>(<span class="params">date, dateString</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(date, dateString);</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">               App...</span></span><br><span class="line"><span class="xml">               <span class="tag">&lt;<span class="name">button</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="symbol">&amp;nbsp;</span></span></span><br><span class="line"><span class="xml">               <span class="tag">&lt;<span class="name">Button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span>&gt;</span>Primary Button<span class="tag">&lt;/<span class="name">Button</span>&gt;</span><span class="symbol">&amp;nbsp;</span></span></span><br><span class="line"><span class="xml">               <span class="tag">&lt;<span class="name">Button</span> <span class="attr">type</span>=<span class="string">&quot;&quot;</span>&gt;</span>Primary Button<span class="tag">&lt;/<span class="name">Button</span>&gt;</span><span class="symbol">&amp;nbsp;</span></span></span><br><span class="line"><span class="xml">               <span class="tag">&lt;<span class="name">DatePicker</span> <span class="attr">onChange</span>=<span class="string">&#123;onChange&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">               <span class="tag">&lt;<span class="name">RangePicker</span> /&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><ol start="3">
<li>antd样式的按需引入，减小项目文件的大小</li>
</ol>
<ul>
<li>找到antd官网 =&gt; 文档 =&gt; 在create-react-app中使用 =&gt; 高级配置 =&gt; 依照官网文档一步步操作执行进行配置的更改</li>
</ul>
</li>
<li><ol start="4">
<li>antd自定义主题</li>
</ol>
<ul>
<li>找到antd官网 =&gt; 文档 =&gt; 在create-react-app中使用 =&gt; 自定义主题 =&gt; 依照官网文档一步步操作执行进行配置的更改</li>
</ul>
</li>
</ul>
<h1 id="第七章-redux"><a href="#第七章-redux" class="headerlink" title="第七章 redux"></a>第七章 redux</h1><h2 id="7-1-redux理解"><a href="#7-1-redux理解" class="headerlink" title="7.1 redux理解"></a>7.1 redux理解</h2><h3 id="7-1-1-学习文档"><a href="#7-1-1-学习文档" class="headerlink" title="7.1.1 学习文档"></a>7.1.1 学习文档</h3><ul>
<li><ol>
<li>英文文档: <a target="_blank" rel="noopener" href="https://redux.js.org/">https://redux.js.org/</a></li>
</ol>
</li>
<li><ol start="2">
<li>中文文档: <a target="_blank" rel="noopener" href="http://www.redux.org.cn/">http://www.redux.org.cn/</a></li>
</ol>
</li>
<li><ol start="3">
<li>Github: <a target="_blank" rel="noopener" href="https://github.com/reactjs/redux">https://github.com/reactjs/redux</a></li>
</ol>
</li>
</ul>
<h3 id="7-1-2-redux是什么"><a href="#7-1-2-redux是什么" class="headerlink" title="7.1.2 redux是什么"></a>7.1.2 redux是什么</h3><ul>
<li><ol>
<li>redux是一个专门用于做<strong>状态管理</strong>的JS库(不是react插件库)。</li>
</ol>
</li>
<li><ol start="2">
<li>它可以用在react, angular, vue等项目中, 但基本与react配合使用。</li>
</ol>
</li>
<li><ol start="3">
<li>作用: 集中式管理react应用中多个组件<strong>共享</strong>的状态。</li>
</ol>
</li>
</ul>
<h3 id="7-1-3-什么情况下需要使用redux"><a href="#7-1-3-什么情况下需要使用redux" class="headerlink" title="7.1.3  什么情况下需要使用redux"></a>7.1.3  什么情况下需要使用redux</h3><ul>
<li><ol>
<li>某个组件的状态，需要让其他组件可以随时拿到（共享）。</li>
</ol>
</li>
<li><ol start="2">
<li>一个组件需要改变另一个组件的状态（通信）。</li>
</ol>
</li>
<li><ol start="3">
<li>总体原则：能不用就不用, 如果不用比较吃力才考虑使用。</li>
</ol>
</li>
</ul>
<h3 id="7-1-4-redux工作流程"><a href="#7-1-4-redux工作流程" class="headerlink" title="7.1.4 redux工作流程"></a>7.1.4 redux工作流程</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1625478862518.png" alt="1625478862518"></p>
<h2 id="7-2-redux的三个核心概念"><a href="#7-2-redux的三个核心概念" class="headerlink" title="7.2  redux的三个核心概念"></a>7.2  redux的三个核心概念</h2><h3 id="7-2-1-action"><a href="#7-2-1-action" class="headerlink" title="7.2.1  action"></a>7.2.1  action</h3><ul>
<li><ol>
<li>动作的对象</li>
</ol>
</li>
<li><ol start="2">
<li>包含2个属性</li>
</ol>
<ul>
<li>type：标识属性, 值为字符串, 唯一, 必要属性</li>
<li>data：数据属性, 值类型任意, 可选属性</li>
</ul>
</li>
<li><ol start="3">
<li>例子：{ type: ‘ADD_STUDENT’,data:{name: ‘tom’,age:18} }</li>
</ol>
</li>
</ul>
<h3 id="7-2-2-reducer"><a href="#7-2-2-reducer" class="headerlink" title="7.2.2  reducer"></a>7.2.2  reducer</h3><ul>
<li><ol>
<li>用于初始化状态、加工状态。</li>
</ol>
</li>
<li><ol start="2">
<li>加工时，根据旧的state和action， 产生新的state的<strong>纯函数</strong>。</li>
</ol>
</li>
</ul>
<h3 id="7-2-3-store"><a href="#7-2-3-store" class="headerlink" title="7.2.3  store"></a>7.2.3  store</h3><ul>
<li><ol>
<li>将state、action、reducer联系在一起的对象</li>
</ol>
</li>
<li><ol start="2">
<li>如何得到此对象?</li>
</ol>
<ul>
<li>1)import {createStore} from ‘redux’</li>
<li>2)import reducer from ‘./reducers’</li>
<li>3)const store = createStore(reducer)</li>
</ul>
</li>
<li><ol start="3">
<li>此对象的功能?</li>
</ol>
<ul>
<li>1)getState(): 得到state</li>
<li>2)dispatch(action): 分发action, 触发reducer调用, 产生新的state</li>
<li>3)subscribe(listener): 注册监听, 当产生了新的state时, 自动调用</li>
</ul>
</li>
</ul>
<h2 id="7-3-redux的使用——精简版"><a href="#7-3-redux的使用——精简版" class="headerlink" title="7.3 redux的使用——精简版"></a>7.3 redux的使用——精简版</h2><h3 id="7-3-1-精简版总结"><a href="#7-3-1-精简版总结" class="headerlink" title="7.3.1 精简版总结"></a>7.3.1 精简版总结</h3><ul>
<li><ol>
<li>去除Count组件自身的状态</li>
</ol>
</li>
<li><ol start="2">
<li>src下建立如下文件夹和文件</li>
</ol>
<ul>
<li>src<ul>
<li>redux<ul>
<li>store.js</li>
<li>count_reducer.js</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ol start="3">
<li>store.js</li>
</ol>
<ul>
<li>(1). 引入redux中的createStore函数，创建一个store</li>
<li>(2). createStore调用时要传入一个为Count组件服务的reducer</li>
<li>(3). 将store对象暴露出去</li>
</ul>
</li>
<li><ol start="4">
<li>count_reducer.js</li>
</ol>
<ul>
<li>(1). reducer的本质是一个函数，接收：preState，action，返回加工后的状态</li>
<li>(2). reducer有两个作用：初始化状态，加工状态</li>
<li>(3). reducer被第一次调用时，是store自动触发的<ul>
<li>传递的preState是undefined</li>
<li>传递的action是{type:‘@@REDUX/INIT_a.2.s.6’}</li>
</ul>
</li>
</ul>
</li>
<li><ol start="5">
<li>在Count组件的index.js中，或在入口文件index.js中监测store中状态，一旦发生改变需重新渲染<App/><br>备注：redux只负责管理状态，至于状态的改变驱动着页面的展示，需自己手动编写</li>
</ol>
</li>
</ul>
<h3 id="7-3-2-具体代码"><a href="#7-3-2-具体代码" class="headerlink" title="7.3.2 具体代码"></a>7.3.2 具体代码</h3><ul>
<li><ol>
<li>安装redux </li>
</ol>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install redux</span><br></pre></td></tr></table></figure>

<ul>
<li><ol start="2">
<li>编写store.js</li>
</ol>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  该文件专门用于暴露一个store对象,整个应用只有一个store对象  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//引入createStore,专门用于创建redux中最为核心的Store对象</span></span><br><span class="line"><span class="keyword">import</span> &#123;createStore&#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="comment">//引入给Count组件服务的reducer</span></span><br><span class="line"><span class="keyword">import</span> countReducer <span class="keyword">from</span> <span class="string">&#x27;./count_reducer&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建store并暴露出去</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> createStore(countReducer)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><ol start="3">
<li>编写count_reducer.js</li>
</ol>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    1.该文件是用于创建一个为Count组件服务的reducer,reducer的本质就是一个函数</span></span><br><span class="line"><span class="comment">    因为需要接收一些数据,处理逻辑,然后返回出去</span></span><br><span class="line"><span class="comment">    2.reducer函数会接到两个参数，分别为：之前的状态（preState），动作对象（action）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">countReducer</span>(<span class="params">preState = initState,action</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//从action中获取type、data</span></span><br><span class="line">    <span class="keyword">const</span> &#123;type,data&#125; = action</span><br><span class="line">    <span class="comment">// 判断获取的类型来执行相应的操作</span></span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> type:<span class="string">&#x27;increment&#x27;</span></span><br><span class="line">            <span class="keyword">return</span> preState + data</span><br><span class="line">        <span class="keyword">case</span> type:<span class="string">&#x27;decrement&#x27;</span></span><br><span class="line">            <span class="keyword">return</span> preState - data</span><br><span class="line">        <span class="attr">default</span>:</span><br><span class="line">            <span class="keyword">return</span> preState</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><ol start="4">
<li>修改Count组件的部分代码</li>
</ol>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取redux的状态</span></span><br><span class="line">store.getState()</span><br><span class="line"><span class="comment">//给count_reducer.js传type、data参数</span></span><br><span class="line">store.dispatch(&#123;<span class="attr">type</span>:<span class="string">&#x27;increment&#x27;</span>,<span class="attr">data</span>:value*<span class="number">1</span>&#125;)</span><br><span class="line"><span class="comment">//重新渲染页面方法一：在Count组件中编写如下代码</span></span><br><span class="line"><span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//检测redux中状态的变化，就调用render</span></span><br><span class="line">    store.subscribe(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.setState(&#123;&#125;)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;调用render&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//重新渲染页面方法一：在入口文件中引入store并编写如下代码</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./redux/store&#x27;</span></span><br><span class="line"></span><br><span class="line">store.subscribe(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">	ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span>/&gt;</span></span>,<span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h2 id="7-4-redux的使用——完整版"><a href="#7-4-redux的使用——完整版" class="headerlink" title="7.4 redux的使用——完整版"></a>7.4 redux的使用——完整版</h2><h3 id="7-4-1-完整版总结"><a href="#7-4-1-完整版总结" class="headerlink" title="7.4.1 完整版总结"></a>7.4.1 完整版总结</h3><ul>
<li>新增文件：<ul>
<li>count_action.js 专门用于创建action对象</li>
<li>constant.js 专门防止容易拼写错误的type值的名字</li>
</ul>
</li>
</ul>
<h2 id="7-5-redux的使用——异步action版"><a href="#7-5-redux的使用——异步action版" class="headerlink" title="7.5 redux的使用——异步action版"></a>7.5 redux的使用——异步action版</h2><h3 id="7-5-1-异步action版总结"><a href="#7-5-1-异步action版总结" class="headerlink" title="7.5.1 异步action版总结"></a>7.5.1 异步action版总结</h3><ul>
<li><ol>
<li>明确：延迟的动作不想交给组件自身，想交给action</li>
</ol>
</li>
<li><ol start="2">
<li>何时需要异步action：想逃对状态进行操作，但是具体的数据靠异步任务返回（非必须）。</li>
</ol>
</li>
<li><ol start="3">
<li>具体编码：</li>
</ol>
<ul>
<li><ol>
<li>下载中间件，和配置store</li>
</ol>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install redux-thunk</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从redux中引入API：applyMiddleware</span></span><br><span class="line"><span class="comment">//将applyMiddleware作为createStore的第二个参数传入，并将thunk作为参数传入applyMiddleware</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> &#123;createStore,applyMiddleware&#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">&#x27;redux-thunk&#x27;</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> createStore(countReducer,applyMiddleware(thunk))</span><br></pre></td></tr></table></figure>

<ul>
<li><ol start="2">
<li>创建action的函数不再返回一般对象，而是一个函数，该函数中写异步任务</li>
</ol>
</li>
<li><ol start="3">
<li>异步任务有结果后，分发一个同步的action去真正操作数据。</li>
</ol>
</li>
</ul>
</li>
<li><ol start="4">
<li>备注：异步action不是必须要写的，完全可以自己等待异步任务的结果了再去分发同步action。</li>
</ol>
</li>
</ul>
<h2 id="7-6-react—redux的基本使用"><a href="#7-6-react—redux的基本使用" class="headerlink" title="7.6 react—redux的基本使用"></a>7.6 react—redux的基本使用</h2><h3 id="7-6-1-react—redux总结"><a href="#7-6-1-react—redux总结" class="headerlink" title="7.6.1 react—redux总结"></a>7.6.1 react—redux总结</h3><ul>
<li><ol>
<li>明确两个概念：</li>
</ol>
<ul>
<li><ol>
<li>UI组件：不能使用任何redux的API，只负责页面的呈现、交互等</li>
</ol>
</li>
<li><ol start="2">
<li>容器组件：负责和redux通信，将结果交给UI组件</li>
</ol>
</li>
</ul>
</li>
<li><ol start="2">
<li>如何创建一个容器组件————靠react-redux 的 connect函数 </li>
</ol>
<ul>
<li>connect(mapStateToProps,mapDispatchToProps)(UI组件)<ul>
<li>mapStateToProps：映射状态，返回值是一个对象</li>
<li>mapDispatchToProps：映射操作状态的方法，返回值是一个对象</li>
</ul>
</li>
</ul>
</li>
<li><ol start="3">
<li>备注：容器组件中的store是靠props传进去的，而不是在容器组件中直接引入</li>
</ol>
</li>
</ul>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://example.com/2020/09/25/react%E5%85%A8%E5%AE%B6%E6%A1%B6%E7%AC%94%E8%AE%B0/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://example.com/2020/09/25/react%E5%85%A8%E5%AE%B6%E6%A1%B6%E7%AC%94%E8%AE%B0/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a target="_blank" rel="noopener" href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
                <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
